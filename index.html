<!DOCTYPE html>
<html>

<head>
    <title>HUPLACLIP experiment</title>
    <!-- My scripts -->
    <script type="text/javascript" src="graphs_functions.js"></script>
    <script type="text/javascript" src="introduction/introduction_pages_generation.js"></script>
    <script type="text/javascript" src="tutorial/tutorial_pages_generation.js"></script>
    <script type="text/javascript" src="experiment_parameters.js"></script>
    <script type="text/javascript" src="canvas_drawing.js"></script>
    <!-- Standard jspsych.js -->
    <script type="text/javascript" src="jspsych/dist/jspsych.js"></script>
    <!-- Standard plugins -->
    <script type="text/javascript" src="jspsych/dist/plugin-instructions.js"></script>
    <script type="text/javascript" src="jspsych/dist/plugin-fullscreen.js"></script>
    <script type="text/javascript" src="jspsych/dist/plugin-image-keyboard-response.js"></script>
    <script type="text/javascript" src="jspsych/dist/plugin-survey-html-form.js"></script>
    <script type="text/javascript" src="jspsych/dist/plugin-html-keyboard-response.js"></script>
    <script type="text/javascript" src="jspsych/dist/plugin-preload.js"></script>
    <!-- Customized plugin -->
    <script type="text/javascript" src="jspsych/dist/my-plugin-canvas-keyboard-response.js"></script>
    <!-- Compressing and de-compressing json files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.11/pako.min.js"></script>
    <!-- Pavlovia connection (COMMENTED FOR OFFLINE VERSION)
    <script type="text/javascript" src="lib/vendors/jquery-2.2.0.min.js"></script>
    <script type="text/javascript" src="jspsych/dist/my-pavlovia.js"></script>
    -->
    <!-- Styling -->
    <link href="jspsych/dist/jspsych.css" rel="stylesheet" type="text/css" />
</head>

<style>
    /* styling can be modified here */
</style>

<body>

    <script type="module">

        // Function to read a compressed file and return a Promise
        function readCompressedGraphFile(url) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.responseType = 'arraybuffer';

                xhr.onload = function () {
                    if (xhr.status === 200) {
                        // File successfully loaded
                        const compressedData = new Uint8Array(xhr.response);

                        // Decompress the data using pako
                        const decompressedData = pako.inflate(compressedData, { to: 'string' });

                        // Parse the decompressed JSON data
                        const graph = JSON.parse(decompressedData);
                        resolve(graph);
                    } else {
                        // File loading failed
                        reject(new Error(`Failed to load file: ${url}`));
                    }
                };

                xhr.onerror = function () {
                    reject(new Error(`Failed to load file: ${url}`));
                };

                xhr.open('GET', url, true);
                xhr.send();
            });
        }

        // Async function to read the graph files
        async function readGraphFiles() {

            /* extract indices of graphs to display */
            let graphsWithCliqueIndices = extractIndices()
            let graphsWithoutCliqueIndices = extractIndices()

            /* generating names of graphs to display and storing them in currentExperiment object  */
            // empty array that will contain the couples of triangular matrices (objects) to be displayed
            let graphsToDisplay = [];

            // number of blocks:
            for (let blockIndex = 0; blockIndex < currentExperiment.numberOfBlocks; blockIndex++) {

                let graphsForCurrentBlock = []

                for (const element of currentExperiment.uniqueCliqueSizes) {

                    // GRAPH WITH CLIQUE, trial 1:
                    // - creating URL:
                    let graphWithClique_trial1_url = `graph_pools/CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithCliqueIndices[element][blockIndex * 2].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_CLIQUE.json`
                    // GRAPH WITHOUT CLIQUE, trial 1:
                    // - creating URL:            
                    let graphWithoutClique_trial1_url = `graph_pools/NO_CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithoutCliqueIndices[element][blockIndex * 2].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_NOCLIQUE.json`

                    // Start reading the files in the background
                    const [graphWithClique1, graphWithoutClique1] = await Promise.all([
                        readCompressedGraphFile(graphWithClique_trial1_url),
                        readCompressedGraphFile(graphWithoutClique_trial1_url)
                    ]);

                    // Adding the two graphs to the array for the current trial (random choice of which one is the first in the couple) and pushing this array into the array relative to the current block
                    if (Math.round(Math.random())) {
                        graphsForCurrentBlock.push([graphWithClique1, graphWithoutClique1])
                    } else {
                        graphsForCurrentBlock.push([graphWithoutClique1, graphWithClique1])
                    }

                    // GRAPH WITH CLIQUE, trial 2:
                    // - creating URL:
                    let graphWithClique_trial2_url = `graph_pools/CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithCliqueIndices[element][blockIndex * 2 + 1].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_CLIQUE.json`
                    // GRAPH WITHOUT CLIQUE, trial 2:
                    // - creating URL:            
                    let graphWithoutClique_trial2_url = `graph_pools/NO_CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithoutCliqueIndices[element][blockIndex * 2 + 1].toString().padStart(4, '0')}_N${currentExperiment.graphSize}_K${element.toString().padStart(4, '0')}_NOCLIQUE.json`

                    // Start reading the files in the background
                    const [graphWithClique2, graphWithoutClique2] = await Promise.all([
                        readCompressedGraphFile(graphWithClique_trial2_url),
                        readCompressedGraphFile(graphWithoutClique_trial2_url)
                    ]);


                    // Adding the two graphs to the array for the current trial (random choice of which one is the first in the couple) and pushing this array into the array relative to the current block
                    if (Math.round(Math.random())) {
                        graphsForCurrentBlock.push([graphWithClique2, graphWithoutClique2])
                    } else {
                        graphsForCurrentBlock.push([graphWithoutClique2, graphWithClique2])
                    }
                }

                // adding array of graphs for current block to array of all graphs
                graphsToDisplay.push(graphsForCurrentBlock)

                console.log("finished reading graphs for block number: " + blockIndex)


            }

            console.log("finished reading all graphs")
            // adding array of graphs to display to currentExperiment object:
            currentExperiment.graphsToDisplay = graphsToDisplay

        }


        // CHECKING DEVICE REQUIREMENTS:
        // - vertical resolution is at least 1080px
        let validVerticalResolutions = [1024, 1080, 1440, 1964]
        if (!validVerticalResolutions.includes(currentExperiment.canvasDimensions[0])) {
            var confirmZoom = confirm("If you are reading this message, make sure to SET YOUR BROWSER ZOOM TO 100% (you can regulate it in the browser options) and click OK.\nThe page will automatically reload and the message should disappear.\n\nIf it does not, the vertical resolution of your device is probably lower than 1024px. Please open the experiment with a device that has higher vertical resolution, and if you still have problems, get in touch with the experimenter.");
            if (confirmZoom == true)
                window.location.reload(); 0
        }
        // - browser is different from Safari (does not allow keboard input when in FullScreen mode)
        let isSafari = window.safari !== undefined
        if (isSafari) alert("Please open the experiment link in a browser different from Safari.")


        /* initializing jspsych */
        var jsPsych = initJsPsych({

            // maximum width of experiment pages
            experiment_width: currentExperiment.canvasDimensions[1],

            // Audio will be played through HTML5, not through WebAudio API
            use_webaudio: false,

            on_finish: function (data) {
                // displaying data:
                jsPsych.data.displayData();
                // local save:
                let currentDate = new Date();
                let fileName = `HUPLACLIP_pilot_${currentDate.getDate()}.${(currentDate.getMonth() + 1)}.${currentDate.getFullYear()}_${currentDate.getHours()}.${currentDate.getMinutes()}.${currentDate.getSeconds()}.csv`
                jsPsych.data.get().localSave('csv', fileName);
            }
        });


        /* create timeline */
        let timeline = [];


        /* init connection with pavlovia.org */
        /*
        var pavlovia_init = {
            type: jsPsychPavlovia,
            command: "init"
        };
        timeline.push(pavlovia_init)
 
 
        /* INTRODUCTIVE PAGES */
        // showing informative pages about the study (informed consent, aim, privacy)
        let introduction = {
            type: jsPsychInstructions,
            pages: generateIntroductionPages(),
            key_forward: "ArrowRight",
            // call the readGraphFiles function when introduction pages are read:
            on_start: readGraphFiles
        }
        timeline.push(introduction)


        /* INSTRUCTIONS */
        /*
        // PRELOADING instructions images:
        // calling function to create filepaths for all instructions images
        let instructions_ImagesArray = createArrayOfFilePaths(instructionsObject, 0)
        // adding preload plugin to timeline
        let preloadInstructions = {
            type: jsPsychPreload,
            images: instructions_ImagesArray,
        }
        timeline.push(preloadInstructions)

        // SHOWING instructions:
        let instructions = {
            type: jsPsychInstructions,
            pages: generateInstructionsPages(),
            key_forward: "ArrowRight",
        }
        timeline.push(instructions)



        /* AGREEMENT TO MOVE TO TASK FAMILIARIZATION */
        /*
        let move_to_familiarization_form = {
            type: jsPsychInstructions,
            pages: [`<p> Now it's your turn! <br>
                From this moment on, you will not be able to move back and forth through the pages. <br><br>
                Press <b>space</b> to start a <b>trial run of the experiment</b>.<br> (for now, your score will not be recorded) <br>
                </p>`],
            key_forward: " "
        };
        timeline.push(move_to_familiarization_form)



        /* TASK FAMILIARIZATION */
        /*
        // PART 1: WITHOUT BACKGROUND INFORMATION
        // PRELOADING images:
        // calling function to create filepaths for all images
        let taskFamiliarization1_ImagesArray = createArrayOfFilePaths(taskFamiliarizationObject_part1, 1)
        // adding preload plugin to timeline
        let preloadTaskFamiliarization1 = {
            type: jsPsychPreload,
            images: taskFamiliarization1_ImagesArray,
        }
        timeline.push(preloadTaskFamiliarization1)

        // creating the trials for the first part of the task familiarization        
        for (let index = 0; index < Object.keys(taskFamiliarizationObject_part1).length; index += 4) {
            // NB: index increases by 4 at every iteration

            // calling function that generates an array containing a single block of 3 trials (visualization 1, visualization 2, choice)
            let currentBlockOfTrialsArray_part1 = generateBlockOfFamiliarizationTrials(1, index, taskFamiliarizationObject_part1)

            // creating the feedback trial and adding it to the array
            let feedback_trial = {
                type: jsPsychImageKeyboardResponse,
                stimulus: `tutorial/task_familiarization_images/part 1/${taskFamiliarizationObject_part1[index + 4][3]}.PNG`,
                prompt: "", //defined below based on correctness of choice
                choices: [' '],
                stimulus_height: currentExperiment.canvasDimensions[0] / 1.6,
                // using a closure (a function that has access to the variables defined in its outer function) to be able to access "index" from inside the on_start function
                on_start: (function (index) {
                    return function (currentFeedbackTrial) {
                        // accessing last trial:
                        let last_trial = jsPsych.data.get().last(1).values()[0];
                        // changing prompt according to correctness of last choice:
                        if (last_trial.response == taskFamiliarizationObject_part1[index + 4][0].toLowerCase()) {
                            currentFeedbackTrial.prompt = `<br><br><br> ${taskFamiliarizationObject_part1[index + 4][1]}`;
                        } else {
                            currentFeedbackTrial.prompt = `<br><br><br> ${taskFamiliarizationObject_part1[index + 4][2]}`;
                        }
                    };
                })(index)
            };
            currentBlockOfTrialsArray_part1.push(feedback_trial)

            // adding all the elments of the array to the timeline
            currentBlockOfTrialsArray_part1.forEach(singleTrial => {
                timeline.push(singleTrial)
            });

        }


        // PART 2: WITH BACKGROUND INFORMATION
        // PRELOADING images:
        // calling function to create filepaths for all images
        let taskFamiliarization2_ImagesArray = createArrayOfFilePaths(taskFamiliarizationObject_part2, 2)
        // adding preload plugin to timeline
        let preloadTaskFamiliarization2 = {
            type: jsPsychPreload,
            images: taskFamiliarization2_ImagesArray,
        }
        timeline.push(preloadTaskFamiliarization2)

        // creating the trials for the second part of the task familiarization        
        for (let index = 0; index < Object.keys(taskFamiliarizationObject_part2).length; index += 4) {
            // NB: index increases by 4 at every iteration

            // calling function that generates an array containing a single block of 3 trials (visualization 1, visualization 2, choice)
            let currentBlockOfTrialsArray_part2 = generateBlockOfFamiliarizationTrials(2, index, taskFamiliarizationObject_part2)

            // creating the feedback trial and adding it to the array
            let feedback_trial = {
                type: jsPsychImageKeyboardResponse,
                stimulus: "", //defined below based on correctness of choice
                prompt: "", //defined below based on correctness of choice
                choices: [' '],
                // stimulus_width: (SPECIFY IF NECESSARY)
                stimulus_height: currentExperiment.canvasDimensions[0] / 1.6,
                // using a closure (a function that has access to the variables defined in its outer function) to be able to access "index" from inside the on_start function
                on_start: (function (index) {
                    return function (currentFeedbackTrial) {
                        // accessing second to last trial:
                        let second_to_last_trial = jsPsych.data.get().last(1).values()[0];
                        // changing prompt according to correctness of last choice:
                        if (second_to_last_trial.response == taskFamiliarizationObject_part2[index + 4][0].toLowerCase()) {
                            currentFeedbackTrial.stimulus = `tutorial/task_familiarization_images/part 2/${taskFamiliarizationObject_part2[index + 4][3]}.PNG`;
                            currentFeedbackTrial.prompt = `<br><br><br> ${taskFamiliarizationObject_part2[index + 4][1]}`;
                        } else {
                            currentFeedbackTrial.stimulus = `tutorial/task_familiarization_images/part 2/${taskFamiliarizationObject_part2[index + 4][4]}.PNG`;
                            currentFeedbackTrial.prompt = `<br><br><br> ${taskFamiliarizationObject_part2[index + 4][2]}`;
                        }
                    };
                })(index)
            };
            currentBlockOfTrialsArray_part2.push(feedback_trial)

            // adding all the elments of the array to the timeline
            currentBlockOfTrialsArray_part2.forEach(singleTrial => {
                timeline.push(singleTrial)
            });
        }

        /* EXPERIMENT STRUCTURE IMAGE */
        /*
        // PRELOADING experiment structure image:
        // adding preload plugin to timeline
        let preloadExpStructureImage = {
            type: jsPsychPreload,
            images: [`tutorial/experiment_structure_images/HUPLACLIP-structure.PNG`],
        }
        timeline.push(preloadExpStructureImage)

        // SHOWING experiment structure image:
        let experiment_structure_image = {
            type: jsPsychInstructions,
            pages: [`<font size="+2"><b> EXPERIMENT STRUCTURE</b></font><br>
                    <img src="tutorial/experiment_structure_images/HUPLACLIP-structure.PNG" alt="Could not upload image" height="${currentExperiment.canvasDimensions[0] / 1.5}"><br><br>
                    The experiment is divided in <b>6 blocks</b> of <b>30 trials</b> each. The difficulty of the task will gradually increase as you progress through each block. 
                    There is no penalty in using shuffles, and you will have <b>10 shuffles for each trial</b>. 
                    Remember that you can use them, especially in harder trials. There is no time limit for completing the task.<br>
                    If you can, raise the volume of your device: the experiment includes audio feedback.<br><br>
                    <i><b>Press right arrow to move on ></b></i>`],
            key_forward: "ArrowRight"
        }
        timeline.push(experiment_structure_image)


        /* COLLECTING DEMOGRAPHIC DATA: */
        /*
        var demographic_survey = {
            type: jsPsychSurveyHtmlForm,
            preamble: '<p>Please answer the following questions:</p>',
            html: `
            <label for="gender">Indicate your gender:</label>
            <select id="gender" name="gender" required>
                <option value="" disabled selected>Select an option</option>
                <option value="male">Male</option>
                <option value="female">Female</option>
                <option value="transgender">Transgender</option>
                <option value="other">Other</option>
                <option value="not-specified">Prefer not to say</option>
            </select>
            <br><br><br>
            <label for="age">Indicate your age:</label>
            <input type="text" id="age" name="age" required>
            <br><br>
            `
        };
        timeline.push(demographic_survey)


        /* CONSENT FORM and AGREEMENT TO START EXPERIMENT */
        // informing that the experiment will start and subject agrees
        // POSSIBLE IMPROVEMENT: use external-HTML plugin (with "agreement_page.html"), so that it is possible to use checkbox and check agreement with a function (alert if clicking something else)
        let consent_form = {
            type: jsPsychInstructions,
            pages: [`<p> You have completed the training: after this page, the real experiment will start and your score will be recorded. <br><br>
               By pressing <b>space</b> you are expressing your consent in taking part in the study, and you confirm to: <br>
             - have carefully read the explanations regarding this study and the full experimental procedure;<br>
             - have been informed regarding the aims of the present research;<br>
             - have had the possibility of asking questions regarding any aspect of the experimental procedure and to have obtained satisfying answers;<br>
             - be aware of the possible risks related with the experiment;<br>
             - have received satisfying assurance regarding the confidentiality of the information collected through the testing of your data;<br>
             - be aware that you can withdraw in any phase of the study.<br><br> 
             Press <b>space</b> to start the experiment.
             </p>`],
            key_forward: " ",
            on_finish: function () {
                // Select the element with class "jspsych-display-element"
                var displayElement = document.querySelector('.jspsych-display-element');
                // Add the style attribute with overflow:hidden to prevent subject from scrolling during experiment
                displayElement.style.overflow = 'hidden';
            }
        };
        timeline.push(consent_form)


        /* CONTROLLING THAT FILES HAVE BEEN SUCCESSFULLY LOADED */
        //NB: will only be visualized if graphs have not been loaded yet
        // loading page:
        var loading_page = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: 'Please wait while the experiment is loading...<br><br> (This could take a few minutes, if you are on a slow connection)',
            trial_duration: 1000  //brief presentation (1") so that the loop condition is evaluated continuously
        }
        // loop node:
        let loop_node = {
            timeline: [loading_page],
            loop_function: function () {
                // while currentExperiment.graphsToDisplay has not been completely populated, present the loading page:
                if (!(currentExperiment.hasOwnProperty('graphsToDisplay'))) {
                    console.log("graphs still loading")
                    return true
                }
                else {
                    return false
                }
            }
        }
        // loading completed page:
        var post_loading_page = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: 'Experiment has finished loading.<br><br>Press <b>any key</b> to start.',
        }
        // adding the loop node to the timeline only if currentExperiment.graphsToDisplay has not been completely populated (otherwise it is skipped)
        var if_node = {
            timeline: [loop_node, post_loading_page],
            conditional_function: function () {
                if (!(currentExperiment.hasOwnProperty('graphsToDisplay'))) {
                    return true;
                } else {
                    return false;
                }
            }
        };
        timeline.push(if_node);


        /* entering fullscreen before experiment: */
        var enter_fullscreen = {
            type: jsPsychFullscreen,
            fullscreen_mode: true,
            message: `<p>The experiment will switch to full screen mode when you press the button below</p><br><br>
                      Before pressing the button, make sure that your <b>browser zoom</b> is set at <b>${currentExperiment.scalingFactor * 100}%</b> (you can regulate it in the browser options).<br><br>`
        }
        timeline.push(enter_fullscreen)


        /* ACTUAL EXPERIMENT: */

        /* DRAWING STIMULI: */
        // FUNCTION THAT WILL DRAW THE STIMULI GIVEN THE CHOSEN ORDER OF THE NODES:
        function generateDrawCanvas(blockIndex, presentationIndex) {
            /* INPUT: 
            - blockIndex (the number that identifies the current block)
            - presentationIndex (the number that identifies the couple of graphs that is being displayed)
 
            OUTPUT:
            - display of the stimuli on the screen
            */

            // function that generates the stimuli:
            function drawCanvas(c) {
                // addressing canvas
                let ctx = c.getContext("2d");

                // for each presentation, shuffling the standard order of the nodes:
                let currentTrialOrder = shuffleNodes(currentExperiment.standardOrderOfNodes.slice()).slice(0, currentExperiment.windowSize);

                // accessing the array of the trials completed up to now (used to draw the feedback):
                let currentTrialsArray = jsPsych.data.get().trials;

                // DRAWING ON CANVAS:
                // - wrapping each function call in a promise
                let drawStimulusLeftPromise = new Promise((resolve) => {
                    drawStimulus("left", ctx, blockIndex, presentationIndex, currentTrialOrder);
                    resolve();
                });

                let drawStimulusRightPromise = new Promise((resolve) => {
                    drawStimulus("right", ctx, blockIndex, presentationIndex, currentTrialOrder);
                    resolve();
                });

                let drawDiagonalPromise = new Promise((resolve) => {
                    drawDiagonal(ctx);
                    resolve();
                });

                let drawFeedbackPromise = new Promise((resolve) => {
                    drawFeedback(ctx, blockIndex, presentationIndex, currentTrialsArray);
                    resolve();
                });

                let drawInstructionsReminderPromise = new Promise((resolve) => {
                    drawInstructionsReminder(ctx);
                    resolve();
                });

                // - executing all the promises in parallel and storing variables:
                return Promise.all([
                    drawStimulusLeftPromise,
                    drawStimulusRightPromise,
                    drawDiagonalPromise,
                    drawFeedbackPromise,
                    drawInstructionsReminderPromise
                ]).then(() => {
                    // - order of the nodes (changes from trial to trial and is read in "my-plugin-canvas-keyboard-response.js")
                    jsPsych.data.presentedOrder = currentTrialOrder;
                    // - correct answer (its value is read to compute the "accuracy" variable, does not change from trial to trial but is read to compute "accuracy" variable from plugin)
                    if (currentExperiment.graphsToDisplay[blockIndex][presentationIndex][0][currentExperiment.graphSize].clique_array === "clique is absent") {
                        // if the first stimulus doesn't have the clique, then the graph with the clique (correct answer) is on the right side
                        jsPsych.data.correctResponse = "arrowright";
                    } else {
                        jsPsych.data.correctResponse = "arrowleft";
                    }
                });
            }


            return drawCanvas

        }


        // creating the blocks of the experiment
        for (let blockIndex = 0; blockIndex < currentExperiment.numberOfBlocks; blockIndex++) {

            // creating the trials for the block
            for (let presentationIndex = 0; presentationIndex < currentExperiment.numberOfPresentationsPerBlock; presentationIndex++) {

                // defining the current trial
                let currentTrial = {
                    type: jsPsychCanvasKeyboardResponse,
                    canvas_size: [currentExperiment.canvasDimensions[0], currentExperiment.canvasDimensions[1]], // [height,width]
                    choices: [' ', 'ArrowLeft', 'ArrowRight'],
                    response_ends_trial: true,
                    timeline: [],
                    data: {
                        // storing variables that do not change between trials relative to the same couple of graphs
                        // experiment parameters:
                        block_index: blockIndex,
                        presentation_index: presentationIndex,
                        // graphs parameters:
                        clique_size: currentExperiment.arrayOfCliqueSizes[presentationIndex],
                        graph_size: currentExperiment.graphSize,
                    },
                    on_start: function (currentTrial) {
                        // - when trial starts, graphs have been read:
                        currentTrial.data.graphs_names = [currentExperiment.graphsToDisplay[blockIndex][presentationIndex][0][currentExperiment.graphSize].graph_name, currentExperiment.graphsToDisplay[blockIndex][presentationIndex][1][currentExperiment.graphSize].graph_name]
                        // - accessing the data stored up to now (it will increase progressively):
                        let currentData = jsPsych.data.get()
                        // - if no more shuffles are available, only allowing final answers (arrow presses):
                        if (currentData.trials.filter(element => element.block_index == blockIndex && element.presentation_index == presentationIndex).length == currentExperiment.maximumNumberOfShuffles)
                            currentTrial.choices = ['ArrowLeft', 'ArrowRight']
                    },
                    on_finish: function (data) {
                        // providing audio feedback based on last response (shuffle, correct answer, wrong answer) (ALTERNATIVE: using JSPsych audioKeboard plugin (https://groups.google.com/g/jspsych/c/y0qYDhKVOXw) ):
                        let lastTrial = jsPsych.data.get().last(1).values()[0]
                        let audioFilePath = ''
                        if (lastTrial.response == " ")
                            audioFilePath = 'audio_feedback/shuffles/shuffle01.mp3'
                        else
                            // if final answer, play sound based on correct / wrong answer
                            if (lastTrial.accuracy)
                                audioFilePath = 'audio_feedback/right/coin01.mp3'
                            else
                                audioFilePath = 'audio_feedback/wrong/error01.mp3'
                        let feedbackAudio = new Audio(audioFilePath);
                        feedbackAudio.play();
                    },
                }

                // adding the stimuli to the timeline of the trial
                // NB: shuffling of nodes is done inside draw function
                currentTrial.timeline.push({ stimulus: generateDrawCanvas(blockIndex, presentationIndex) })

                // repeating the trial until a final answer (left/right arrow press) is given:
                let loop_node = {
                    timeline: [currentTrial],
                    loop_function: function () {
                        // accessing the data stored up to now (it will increase progressively):
                        let currentData = jsPsych.data.get()
                        if (currentData.last(1).values()[0].response == " ") {
                            // if last response was a spacebar press, repeat the trial
                            return true
                        } else if (currentData.last(1).values()[0].response == 0 || currentData.last(1).values()[0].response == 1) {
                            // if last response was on left/right arrow, moving to next trial
                            return false
                        }

                    }
                }

                // adding the loop node to the timeline
                timeline.push(loop_node)

            }

            // after each block, present break page
            switch (blockIndex) {
                // if last block just presented, final page will be different
                case (currentExperiment.numberOfBlocks - 1):
                    /* FINAL PAGE */
                    let final_page = {
                        type: jsPsychInstructions,
                        pages: [], // defined inside on_start function (below)
                        key_forward: " ",
                        on_start: function (final_page) {
                            // accessing the array of all the trials completed up to now:
                            let currentTrialsArray = jsPsych.data.get().trials
                            let arrayOfResponsesLastBlock = []  //to compute block score
                            let arrayOfResponses = []   //to compute total score
                            currentTrialsArray.forEach(element => {
                                // creating array of final responses for current block:
                                if (element.block_index == blockIndex && element.hasOwnProperty('accuracy'))
                                    arrayOfResponsesLastBlock.push(element.accuracy)
                                // creating array of all final responses:
                                if (element.hasOwnProperty('accuracy'))
                                    arrayOfResponses.push(element.accuracy)
                            })
                            // computing score:
                            // - last block score:
                            let numberOfCorrectResponsesLastBlock = arrayOfResponsesLastBlock.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponsesLastBlock = arrayOfResponsesLastBlock.length
                            // - total score:
                            let numberOfCorrectResponses = arrayOfResponses.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponses = arrayOfResponses.length
                            // last trial feedaback: changing background color of SCORE based on correctness of last response
                            let scoreColor = "black"
                            if (arrayOfResponsesLastBlock[arrayOfResponsesLastBlock.length - 1]) {
                                scoreColor = "lawngreen"
                            } else {
                                scoreColor = "red"
                            }
                            final_page.pages = [
                                `<p> 
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:${scoreColor};color:black;display:inline-block;">SCORE: ${numberOfCorrectResponsesLastBlock} / ${numberOfFinalResponsesLastBlock}</div>
                                <br><br><br>                             
                                You completed all the <b> ${currentExperiment.numberOfBlocks}</b> blocks of the experiment. <br><br>
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:gold;color:black;display:inline-block;">TOTAL SCORE: ${numberOfCorrectResponses} / ${numberOfFinalResponses}</div>
                                <br><br>
                                Thank you for your time.
                                <br><br>
                                Press <b>space</b> to exit.
                                </p>`]
                        }
                    };
                    timeline.push(final_page)
                    break;
                default:
                    /* AGREEMENT TO MOVE TO NEXT BLOCK */
                    let move_to_next_block = {
                        type: jsPsychInstructions,
                        pages: [], // defined inside on_start function (below)
                        key_forward: " ",
                        on_start: function (move_to_next_block) {
                            // accessing the array of the trials completed up to now:
                            let currentTrialsArray = jsPsych.data.get().trials
                            let arrayOfResponsesPerBlock = []
                            currentTrialsArray.forEach(element => {
                                // creating array of final responses for current block:
                                if (element.block_index == blockIndex && element.hasOwnProperty('accuracy'))
                                    arrayOfResponsesPerBlock.push(element.accuracy)
                            })
                            // calculating accuracy for current block:
                            let numberOfCorrectResponsesPerBlock = arrayOfResponsesPerBlock.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponsesPerBlock = arrayOfResponsesPerBlock.length
                            // last trial feedback: changing background color of SCORE based on correctness of last response
                            let scoreColor = "black"
                            if (arrayOfResponsesPerBlock[arrayOfResponsesPerBlock.length - 1]) {
                                scoreColor = "lawngreen"
                            } else {
                                scoreColor = "red"
                            }
                            move_to_next_block.pages = [
                                `<p> 
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:${scoreColor};color:black;display:inline-block;">SCORE: ${numberOfCorrectResponsesPerBlock} / ${numberOfFinalResponsesPerBlock}</div>
                                    <br><br>
                                    So far, you have completed <b> ${(blockIndex + 1)} </b> out of <b>${currentExperiment.numberOfBlocks}</b> blocks. <br>
                                    You still have <b> ${currentExperiment.numberOfBlocks - (blockIndex + 1)} </b> to go.
                                    <br><br>
                                    Remember: <br>
                                    - Press <b> LEFT / RIGHT arrow </b> to choose the triangle with the hidden red tiles. <br>
                                    - Press <b> SPACE </b> to shuffle the triangles. <br><br>
                                    When you feel ready, press <b>space</b> to move to the next block.
                                  </p>`]
                        }
                    };
                    timeline.push(move_to_next_block)
            }

        }


        /* exiting fullscreen after experiment: */
        var exit_fullscreen = {
            type: jsPsychFullscreen,
            fullscreen_mode: false,
            delay_after: 0
        }
        timeline.push(exit_fullscreen)


        /* finish connection with pavlovia.org */
        /*
        var pavlovia_finish = {
            type: jsPsychPavlovia,
            command: "finish",
            participantId: "JSPSYCH-DEMO",
 
            //NECESSARY WHEN ADDING PROLIFIC:
            //completedCallback: function (){
            //    window.location.replace('https://app.prolific.co/submissions/complete?cc=C180BZKR');
            //},
 
        };
        timeline.push(pavlovia_finish)
        */


        /* start the experiment */
        jsPsych.run(timeline);

    </script>

</body>

</html>