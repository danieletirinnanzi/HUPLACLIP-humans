<!DOCTYPE html>
<html>

<head>
    <title>HUPLACLIP experiment</title>
    <!-- My scripts -->
    <script type="text/javascript" src="graphs_functions.js"></script>
    <script type="text/javascript" src="introduction_pages_generation.js"></script>
    <script type="text/javascript" src="tutorial/tutorial_pages_generation.js"></script>
    <script type="text/javascript" src="experiment_parameters.js"></script>
    <script type="text/javascript" src="canvas_drawing.js"></script>
    <!-- Standard jspsych.js -->
    <script type="text/javascript" src="plugins/standard_plugins/jspsych.js"></script>
    <!-- Standard plugins -->
    <script type="text/javascript" src="plugins/standard_plugins/plugin-instructions.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-fullscreen.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-image-keyboard-response.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-survey-html-form.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-html-keyboard-response.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-preload.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-audio-keyboard-response.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-browser-check.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-call-function.js"></script>    
    <!-- Customized plugin -->
    <script type="text/javascript" src="plugins/my-plugin-canvas-keyboard-response.js"></script>  
    <!-- Compressing and de-compressing json files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.11/pako.min.js"></script>
    <!-- Styling -->
    <link href="plugins/standard_plugins/jspsych.css" rel="stylesheet" type="text/css" />
</head>

<style>
    /* styling can be modified here */
</style>

<body>

    <script type="module">

        // Function to read a compressed file and return a Promise
        function readCompressedGraphFile(url) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.responseType = 'arraybuffer';

                xhr.onload = function () {
                    if (xhr.status === 200) {
                        // File successfully loaded
                        const compressedData = new Uint8Array(xhr.response);

                        // Decompress the data using pako
                        const decompressedData = pako.inflate(compressedData, { to: 'string' });

                        // Parse the decompressed JSON data
                        const graph = JSON.parse(decompressedData);
                        resolve(graph);
                    } else {
                        // File loading failed
                        reject(new Error(`Failed to load file: ${url}`));
                    }
                };

                xhr.onerror = function () {
                    reject(new Error(`Failed to load file: ${url}`));
                };

                xhr.open('GET', url, true);
                xhr.send();
            });
        }

        // Async function to read the graph files
        async function readGraphFiles() {

            /* extract indices of graphs to display */
            let graphsWithCliqueIndices = extractIndices()
            let graphsWithoutCliqueIndices = extractIndices()

            /* generating names of graphs to display and storing them in currentExperiment object  */
            // empty array that will contain the couples of triangular matrices (objects) to be displayed
            let graphsToDisplay = [];

            // number of blocks:
            for (let blockIndex = 0; blockIndex < currentExperiment.numberOfBlocks; blockIndex++) {

                let graphsForCurrentBlock = []

                for (const element of currentExperiment.uniqueCliqueSizes) {

                    // GRAPH WITH CLIQUE, trial 1:
                    // - creating URL:
                    let graphWithClique_trial1_url = `graph_pools/${currentExperiment.KGridScaling}/${currentExperiment.pCorrectionType}/N${currentExperiment.graphSize.toString().padStart(4, '0')}/CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithCliqueIndices[element][blockIndex * 2].toString().padStart(4, '0')}_N${currentExperiment.graphSize.toString().padStart(4, '0')}_K${element.toString().padStart(4, '0')}_CLIQUE.json`
                    // GRAPH WITHOUT CLIQUE, trial 1:
                    // - creating URL:            
                    let graphWithoutClique_trial1_url = `graph_pools/${currentExperiment.KGridScaling}/${currentExperiment.pCorrectionType}/N${currentExperiment.graphSize.toString().padStart(4, '0')}/NO_CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithoutCliqueIndices[element][blockIndex * 2].toString().padStart(4, '0')}_N${currentExperiment.graphSize.toString().padStart(4, '0')}_K${element.toString().padStart(4, '0')}_NOCLIQUE.json`

                    // Start reading the files in the background
                    const [graphWithClique1, graphWithoutClique1] = await Promise.all([
                        readCompressedGraphFile(graphWithClique_trial1_url),
                        readCompressedGraphFile(graphWithoutClique_trial1_url)
                    ]);

                    // Adding the two graphs to the array for the current trial (random choice of which one is the first in the couple) and pushing this array into the array relative to the current block
                    if (Math.round(Math.random())) {
                        graphsForCurrentBlock.push([graphWithClique1, graphWithoutClique1])
                    } else {
                        graphsForCurrentBlock.push([graphWithoutClique1, graphWithClique1])
                    }

                    // GRAPH WITH CLIQUE, trial 2:
                    // - creating URL:
                    let graphWithClique_trial2_url = `graph_pools/${currentExperiment.KGridScaling}/${currentExperiment.pCorrectionType}/N${currentExperiment.graphSize.toString().padStart(4, '0')}/CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithCliqueIndices[element][blockIndex * 2 + 1].toString().padStart(4, '0')}_N${currentExperiment.graphSize.toString().padStart(4, '0')}_K${element.toString().padStart(4, '0')}_CLIQUE.json`
                    // GRAPH WITHOUT CLIQUE, trial 2:
                    // - creating URL:            
                    let graphWithoutClique_trial2_url = `graph_pools/${currentExperiment.KGridScaling}/${currentExperiment.pCorrectionType}/N${currentExperiment.graphSize.toString().padStart(4, '0')}/NO_CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithoutCliqueIndices[element][blockIndex * 2 + 1].toString().padStart(4, '0')}_N${currentExperiment.graphSize.toString().padStart(4, '0')}_K${element.toString().padStart(4, '0')}_NOCLIQUE.json`

                    // Start reading the files in the background
                    const [graphWithClique2, graphWithoutClique2] = await Promise.all([
                        readCompressedGraphFile(graphWithClique_trial2_url),
                        readCompressedGraphFile(graphWithoutClique_trial2_url)
                    ]);


                    // Adding the two graphs to the array for the current trial (random choice of which one is the first in the couple) and pushing this array into the array relative to the current block
                    if (Math.round(Math.random())) {
                        graphsForCurrentBlock.push([graphWithClique2, graphWithoutClique2])
                    } else {
                        graphsForCurrentBlock.push([graphWithoutClique2, graphWithClique2])
                    }
                }

                // adding array of graphs for current block to array of all graphs
                graphsToDisplay.push(graphsForCurrentBlock)

                console.log("finished reading graphs for block number: " + blockIndex)

            }

            console.log("finished reading graphs")
            // adding array of graphs to display to currentExperiment object:
            currentExperiment.graphsToDisplay = graphsToDisplay

            // Printing the currentExperiment object to the console
            //console.log(currentExperiment)

        }


        /* initializing jspsych */
        var jsPsych = initJsPsych({

            // maximum width of experiment pages (logical coordinates)
            experiment_width: screen.width,

            // Minimum valid reaction time (in ms) for keyboard responses
            minimum_valid_rt: 10,

            // Audio will be played through HTML5, not through WebAudio API
            use_webaudio: false,

            // preloading files that can be automatically detected from the timeline:
            auto_preload: true,

            on_finish: function (data) {
                // displaying data:
                jsPsych.data.displayData();
                //local save (when running on LOCAL BROWSER):
                let currentDate = new Date();
                let fileName = `HUPLACLIP-${currentExperiment.graphSize}_pilot_${currentDate.getDate()}.${(currentDate.getMonth() + 1)}.${currentDate.getFullYear()}_${currentDate.getHours()}.${currentDate.getMinutes()}.${currentDate.getSeconds()}.csv`
                jsPsych.data.get().localSave('csv', fileName);
            }
        });


        /* create timeline */
        let timeline = [];

        /* init connection with pavlovia.org */
        if (document.location.hostname == "run.pavlovia.org"){

            // capture info from Prolific URL variables and add them to the data:
            var subject_id = jsPsych.data.getURLVariable('PROLIFIC_PID');
            var study_id = jsPsych.data.getURLVariable('STUDY_ID');
            var session_id = jsPsych.data.getURLVariable('SESSION_ID');
            jsPsych.data.addProperties({
                subject_id: subject_id,
                study_id: study_id,
                session_id: session_id
            });            

            var pavlovia_init = {
                type: jsPsychPavlovia,
                command: "init",              
            };
            timeline.push(pavlovia_init);
          }           

        /* CHECKING DEVICE/BROWSER REQUIREMENTS */

        //NOTE: logic (it should be working on Safari as well)
        // 1. browser-check 1 -> checking if full-screen is supported and if the device is not mobile/tablet;
        // 2. calling function to retrieve vertical resolution of device, checking its validity and storing it in the currentExperiment object;

        // defining boolean variable to check if the device is a tablet
        const userAgent = navigator.userAgent.toLowerCase();
        const isTablet = /(ipad|tablet|(android(?!.*mobile))|(windows(?!.*phone)(.*touch))|kindle|playbook|silk|(puffin(?!.*(IP|AP|WP))))/.test(userAgent);        
        
        // TO REMOVE        
        //console.log("Is tablet: ", isTablet);
        
        // 1. browser-check 1 (checking that browser is an accepted one, full-screen is supported, and device is not mobile)                
        var browser_check = {
            type: jsPsychBrowserCheck,
            inclusion_function: (data) => {
                let acceptedBrowsers = ['chrome', 'firefox', 'edge', 'edge-chromium', 'edge-ios'];
                let isAcceptedBrowser = acceptedBrowsers.includes(data.browser);
                let isNotMobile = data.mobile === false && !isTablet;
                let isFullscreenSupported = data.fullscreen === true;
        
                // Initialize stopReason as an empty array
                data.stopReason = [];
        
                // Check each condition and add the reason to the array if it fails
                if (!isAcceptedBrowser) {
                    data.stopReason.push(`Browser: ${data.browser} is not supported`);
                }
                if (!isNotMobile) {
                    data.stopReason.push(`Device is mobile or tablet`);
                }
                if (!isFullscreenSupported) {
                    data.stopReason.push(`Fullscreen is not supported`);
                }

                // Add stopReason to the jsPsych global data store
                jsPsych.data.addProperties({ stopReason: data.stopReason });               
                
                // Print the stopReason to the console
                console.log("Browser_check stop reasons: ", data.stopReason);

                // Return true if all conditions are met, otherwise false
                return isAcceptedBrowser && isNotMobile && isFullscreenSupported;
            },
            exclusion_message: (data) => {
                // Join all reasons into a single string
                let stopReasons = jsPsych.data.dataProperties.stopReason;
        
                // Generate a dynamic exclusion message based on the reasons
                let message = `<p style="color: red"><strong>WARNING: DEVICE OR BROWSER ISSUE DETECTED!</strong></p>
                               <p>The following issues were detected:</p>
                               <ul>`;
                stopReasons.forEach(reason => {
                    message += `<li>${reason}</li>`;
                });
                message += `</ul>
                            <p>Please address the issues above by changing device or browser and try again.</p>
                            <p>If the present message does not disappear, you are <b>failing to meet some key requirements</b> and cannot complete the experiment.<br>
                            Click the button below to <b>return your submission</b>:</p>
                            <button style="font-size: 18px; padding: 10px 20px;" onclick="window.location.href='https://www.google.com/'">Return to Prolific</button>
                            <br><br>
                            <p style="font-size: 15px;">To report any issues, please contact the experimenter at <a href="mailto:dtirinna@sissa.it">dtirinna@sissa.it</a></p>`;
        
                return message;
            },
        }
        timeline.push(browser_check) 

        // 2. function to retrieve vertical resolution of device, checking its validity and storing it in the currentExperiment object;
        var device_check = {
            type: jsPsychCallFunction,
            func: function (data) {
                // - retrieving the physical screen dimensions using the devicePixelRatio -> has to be an accepted one, and devicePixelRatio has to be an integer (only devicePixelRatio = [1.25, 1.50, 1.75] are accepted to account for Display scaling)
                let physicalScreenDimensions = {
                    width: window.screen.width * window.devicePixelRatio | 0,
                    height: window.screen.height * window.devicePixelRatio | 0
                };

                // TO REMOVE      
                //console.log("Device Pixel Ratio is: ", devicePixelRatio)
                
                // TO REMOVE
                //console.log("True Physical Screen Width: ", physicalScreenDimensions.width);
                //console.log("True Physical Screen Height: ", physicalScreenDimensions.height);

                // - defining valid vertical resolutions based on the graph size -> used to evaluate the validity of the retrieved resolution
                // NOTE: the list of vertical resolutions is needed because if the browser's zoom is not set to 100%, the retrieved resolution might be different from the physical one
                switch (currentExperiment.graphSize) {
                    case 100:
                    case 150:
                    case 200:
                    case 300:
                    case 400:
                    case 480:
                    case 600:
                        var validVerticalResolutions = [720, 768, 832, 864, 900, 1024, 1050, 1080, 1152, 1200, 1344, 1392, 1400, 1440, 1504, 1536, 1600, 1664, 1800, 1824, 1864, 1912, 1920, 1964, 2160, 2234, 2304, 2400, 2520, 2880, 3200, 3328, 3384, 3600, 3840, 4000, 4320, 4468, 5760];
                        break;
                    case 800:
                        var validVerticalResolutions = [832, 864, 900, 1024, 1050, 1080, 1152, 1200, 1344, 1392, 1400, 1440, 1504, 1536, 1600, 1664, 1800, 1824, 1864, 1912, 1920, 1964, 2160, 2234, 2304, 2400, 2520, 2880, 3200, 3328, 3384, 3600, 3840, 4000, 4320, 4468, 5760];
                        break;
                    case 1000:
                        var validVerticalResolutions = [1024, 1050, 1080, 1152, 1200, 1344, 1392, 1400, 1440, 1504, 1536, 1600, 1664, 1800, 1824, 1864, 1912, 1920, 1964, 2160, 2234, 2304, 2400, 2520, 2880, 3200, 3328, 3384, 3600, 3840, 4000, 4320, 4468, 5760];
                        break;
                    default:
                        alert(`Invalid graph size, check the "experiment_parameters.js" file (line 11). Graph size is set to ${currentExperiment.graphSize}, while allowed graph size values for human experiments are: 100, 150, 200, 300, 400, 480, 600, 800, 1000.`);
                        break;
                }                
                
                // - calculating the dimension of the single square -> has to be >= 1 pixel, and is used to calculate the proportion of vertical dimension occupied by the stimuli
                let numberOfSquares = currentExperiment.graphSize + 2   // number of squares to be drawn in the two directions (2 squares are for the diagonal):
                let squareSideDimensionPhysical = Math.floor(physicalScreenDimensions.height / numberOfSquares) // resulting square side dimension           

                // - calculating the proportion of vertical dimension that is occupied by the stimuli -> has to be >= 75%
                let stimuliVerticalDimension = numberOfSquares * squareSideDimensionPhysical
                let stimuliVerticalProportion = stimuliVerticalDimension / physicalScreenDimensions.height      
                stimuliVerticalProportion = Math.round(stimuliVerticalProportion * 100) / 100;  // rounding to 2 decimal values

                // - storing the values in the currentExperiment object:
                currentExperiment.screenWidth = physicalScreenDimensions.width;
                currentExperiment.screenHeight = physicalScreenDimensions.height;
                currentExperiment.stimuliVerticalProportion = stimuliVerticalProportion; 
                currentExperiment.validVerticalResolutions = validVerticalResolutions;               

                // TO REMOVE
                //console.log("Square side dimension physical ", squareSideDimensionPhysical)
                //console.log("Stimuli vertical dimension: ", stimuliVerticalDimension)
                //console.log("Stimuli vertical proportion: ", stimuliVerticalProportion)

                // checking that all conditions are met: vertical resolution is valid; square side dimension is >= 1 pixel; devicePixelRatio is an integer (devicePixelRatio = [1.25, 1.5, 1.75] are accepted to account for Display scaling values); stimuli occupy a minimum % of the vertical dimension of the screen
                if (validVerticalResolutions.includes(physicalScreenDimensions.height) && squareSideDimensionPhysical >= 1 && (Number.isInteger(window.devicePixelRatio) || [1.25, 1.5, 1.75].includes(window.devicePixelRatio)) && stimuliVerticalProportion >= currentExperiment.stimuliVerticalProportionThreshold) {
                    // valid resolution -> calling function to calculate drawing parameters and storing them in the currentExperiment object:
                    currentExperiment.fixedDrawingParameters = calculateFixedDrawingParameters(physicalScreenDimensions.width, physicalScreenDimensions.height, currentExperiment.graphSize);

                    // calling function to calculate coordinates of left and right triangles and storing them in the currentExperiment object:
                    let leftAndRightTriangleCoordinates = calculateTrianglesCoordinates(currentExperiment.fixedDrawingParameters, currentExperiment.graphSize);
                    currentExperiment.stimuliCoordinates = {};
                    currentExperiment.stimuliCoordinates.leftTriangle = leftAndRightTriangleCoordinates[0];
                    currentExperiment.stimuliCoordinates.rightTriangle = leftAndRightTriangleCoordinates[1];  
                                    
                    return; // Stop further execution
                } else {
                    // invalid resolution -> redirect to Prolific, differentiating message based on the detected issue
                    let title;
                    let message;
                    if (stimuliVerticalProportion < currentExperiment.stimuliVerticalProportionThreshold && validVerticalResolutions.includes(physicalScreenDimensions.height) ) {
                        title = "WARNING: STIMULUS RENDERING ISSUE DETECTED!";
                        message = `If you have set your browser zoom to 100% but this message does not disappear, the <b>visual rendering of the experiment on your current device is suboptimal</b>.
                                    Try opening the experiment on a different device.`;
                    } else {
                        // if vertical resolution is not accepted || square side dimension is < 1 pixel || devicePixelRatio is not an integer (only devicePixelRatio = [1.25, 1.50, 1.75] are accepted)
                        title = "WARNING: SCREEN RESOLUTION ISSUE DETECTED!";
                        message = `If you have set your browser zoom to 100% but this message does not disappear, you <b>might be using an incompatible device</b>.
                                    A vertical resolution of at least <b>${validVerticalResolutions[0]}</b> is required to run the experiment (you can check the resolution of your device in the device settings).
                                    If your current device does not meet this requirement, try opening the experiment on a device with higher resolution.`;
                    }
                    document.body.innerHTML = `
                    <div style="text-align: left; padding: 20px;">
                        <p style="color: red"><strong>${title}</strong></p>                        
                            <p>If you are seeing this message, make sure to:
                                <ul>
                                    <li><b>Set your browser zoom to 100%</b> (you can change it in the browser options or by pressing "Ctrl +" / "Ctrl -" (Windows) or "⌥ ⌘ =" / "⌥ ⌘ -" (Mac) ) and <b>click on the "Reload Page" button below</b>. The page will reload and this message should not be shown anymore.</li>
                                    <button style="font-size: 18px; padding: 10px 20px;" onclick="window.location.reload()">Reload Page</button><br><br>                        
                                    <li>${message}<br> 
                                    <p>If the present message does not disappear, you are <b>failing to meet some key requirements</b> and cannot complete the experiment.<br>
                                    Click the button below to <b>return your submission</b>:</p>                                    
                                    <button style="font-size: 18px; padding: 10px 20px;" onclick="window.location.href='https://www.google.com/'">Return to Prolific</button>
                                </ul>
                            </p>                               
                            <br>
                        <p style="font-size: 15px;">To report any issues, please contact the experimenter at <a href="mailto:dtirinna@sissa.it">dtirinna@sissa.it</a></p>
                    </div>
                `;                       
                return // Stop further execution
                }             
            },
            on_finish: function (data) {
                // if current device is accepted, storing display variables in "data" object of current trial:
                if (currentExperiment.screenWidth && currentExperiment.screenHeight && currentExperiment.fixedDrawingParameters) {
                    data.screenWidth = currentExperiment.screenWidth;
                    data.screenHeight = currentExperiment.screenHeight;
                    data.stimuliVerticalProportion = currentExperiment.stimuliVerticalProportion;
                    data.pCorrectionType = currentExperiment.pCorrectionType;
                    data.KGridScaling = currentExperiment.KGridScaling;
                } else {
                    // re-computing the physical screen dimensions and square side dimension in case of device check failure
                    let squareSideDimensionPhysical = Math.floor(currentExperiment.screenHeight / (currentExperiment.graphSize + 2)); // re-computing the square side dimension

                    data.screenHeight = `DEVICE CHECK FAILED, height: ${currentExperiment.screenHeight}`;
                    data.squareSideDimensionPhysical = `DEVICE CHECK FAILED, square side dimension: ${squareSideDimensionPhysical}`; // re-computing the square side dimension
                    data.devicePixelRatio = `DEVICE CHECK FAILED, device pixel ratio: ${window.devicePixelRatio}`;
                    data.stimuliVerticalProportion = `DEVICE CHECK FAILED, stimuli vertical proportion: ${currentExperiment.stimuliVerticalProportion}`;
            
                    // Initialize stopReason as an empty array
                    data.stopReason = [];
            
                    // Check each condition and add the reason to the array if it fails
                    if (!currentExperiment.validVerticalResolutions.includes(currentExperiment.screenHeight)) {
                        data.stopReason.push(`height: ${currentExperiment.screenHeight} not in ${currentExperiment.validVerticalResolutions}`);
                    }
                    if (squareSideDimensionPhysical < 1) {
                        data.stopReason.push(`square side dimension: ${squareSideDimensionPhysical} is less than 1`);
                    }
                    if (!Number.isInteger(window.devicePixelRatio) && ![1.25, 1.5, 1.75].includes(window.devicePixelRatio)) {
                        data.stopReason.push(`device pixel ratio: ${window.devicePixelRatio} is not valid`);
                    }
                    if (currentExperiment.stimuliVerticalProportion < currentExperiment.stimuliVerticalProportionThreshold) {
                        data.stopReason.push(`stimuli vertical proportion: ${currentExperiment.stimuliVerticalProportion} is less than threshold (${currentExperiment.stimuliVerticalProportionThreshold})`);
                    }
            
                    // Join all reasons into a single string
                    data.stopReason = `STOP REASONS: ${data.stopReason.join('; ')}`;
                }
                
                // Printing the data object to the console:
                console.log("Device_check data: ", data);
            } 
        }
        timeline.push(device_check)

        // PRELOADING feedback audio files:
        let preloadAudioFiles = {
            type: jsPsychPreload,
            audio: ['audio_feedback/shuffles/shuffle.mp3', 'audio_feedback/right/right.mp3', 'audio_feedback/wrong/wrong.mp3'],
        }
        timeline.push(preloadAudioFiles)              


        /* INTRODUCTIVE PAGES */
        // showing informative pages about the study (informed consent, aim, privacy)
        let introduction = {
            type: jsPsychInstructions,
            pages: generateIntroductionPages(),
            key_forward: "ArrowRight",
            // call the readGraphFiles function when introduction pages are read:
            on_start: readGraphFiles
        }
        timeline.push(introduction)


        /* CONSENT FORM (for Prolific integration, new version) */
        // standard consent form
        var consent1 = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus:
              `By accepting to participate in this study, you confirm:
                <p style=\'text-align:left\'>
                    - That I have carefully read the explanations regarding this study and the entire experimental procedure;<br>
                    - That I have been informed about the aims and objectives of this research;<br>
                    - That I am aware of the inconveniences, if any, caused by the experiment;<br>
                    - That I have received satisfactory assurances regarding the confidentiality of the information obtained from the examination of my own person; <br>
                    - That I am aware that I can withdraw at any stage of the study.
                <p>
                <span style="color: #808080">
                    Press [Y] to <strong>accept</strong>.
                </span> <br>
                <span style="color: #808080">
                    Press [N] to <strong>refuse</strong>.
                </span>`,
            choices: ["Y", "N"],
          };
    
        // conditional consent form ( to be shown only if subject answers "N" to the first consent form):
        // - consent form content
        var consent2 = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus:
            `Do you confirm you refuse to go on?
            <p> 
                By pressing [Y], you will end the experiment <strong>without reward</strong> and will be redirected to Prolific.<br>
                By pressing [N] you will be redirected to the <strong>informed consent</strong> to read again the informations and accept the conditions.
            <p>
                <span style="color: #808080">Press [Y] to <strong>end the experiment</strong>.</span> <br>
                <span style="color: #808080">Press [N] to <strong>go back to the informed consent page</strong>.</span>`,
        choices: ["Y", "N"],
        on_finish: function (data) {
            if (data.response == "y") {
            // subject refuses to go on, redirect to Prolific
            window.location.replace(
                "https://www.google.com/" // "No consent" code
            );
            }
        },
        };
        // - conditional function
        var conditional_consent = {
        timeline: [consent2],
        conditional_function: function (data) {
            if (jsPsych.data.get().last(1).values()[0].response == "n") {
            return true;
            } else {
            return false;
            }
        },
        };
        // - loop node (keep showing standard consent form if the subject does not confirm he/she wants to exit the experiment)
        var loop_consent = {
        timeline: [consent1, conditional_consent],
        loop_function: function (data) {
            if (jsPsych.data.get().last(1).values()[0].response == "n") {
            return true;
            } else {
            return false;
            }
        },
        };  
        timeline.push(loop_consent)

        /* COLLECTING DEMOGRAPHIC DATA: */
        var demographic_survey = {
            type: jsPsychSurveyHtmlForm,
            preamble: '<p>Please answer the following questions:</p>',
            html: `
            <label for="gender">Indicate your gender:</label>
            <select id="gender" name="gender" required>
                <option value="" disabled selected>Select an option</option>
                <option value="male">Male</option>
                <option value="female">Female</option>
                <option value="transgender">Transgender</option>
                <option value="other">Other</option>
                <option value="not-specified">Prefer not to say</option>
            </select>
            <br><br><br>
            <label for="age">Indicate your age:</label>
            <input type="number" id="age" name="age" required>
            <br><br>
            After submitting a response, you will see the instructions for the experiment.
             <br><br>
            `
        };
        timeline.push(demographic_survey)        

        /* INSTRUCTIONS */
        // PRELOADING instructions images:
        // calling function to create filepaths for all instructions images
        let instructions_ImagesArray = createArrayOfFilePaths(instructionsObject, 0)
        // adding preload plugin to timeline
        let preloadInstructions = {
            type: jsPsychPreload,
            images: instructions_ImagesArray,
        }
        timeline.push(preloadInstructions)

        // SHOWING instructions:
        let instructions = {
            type: jsPsychInstructions,
            pages: generateInstructionsPages(),
            key_forward: "ArrowRight",
        }
        timeline.push(instructions)



        /* AGREEMENT TO MOVE TO TASK FAMILIARIZATION */
        let move_to_familiarization_form = {
            type: jsPsychInstructions,
            pages: [`<p> Now it's your turn! <br>
                From this moment on, you will not be able to move back and forth through the pages. <br><br>
                Press <b>space</b> to start a <b>trial run of the experiment</b>.<br> (for now, your score will not be recorded) <br>
                </p>`],
            key_forward: " "
        };
        timeline.push(move_to_familiarization_form)



        /* TASK FAMILIARIZATION */
        // PART 1: WITHOUT BACKGROUND INFORMATION
        // PRELOADING images:
        // calling function to create filepaths for all images
        let taskFamiliarization1_ImagesArray = createArrayOfFilePaths(taskFamiliarizationObject_part1, 1)
        // adding preload plugin to timeline
        let preloadTaskFamiliarization1 = {
            type: jsPsychPreload,
            images: taskFamiliarization1_ImagesArray,
        }
        timeline.push(preloadTaskFamiliarization1)

        // creating the trials for the first part of the task familiarization        
        for (let index = 0; index < Object.keys(taskFamiliarizationObject_part1).length; index += 4) {
            // NB: index increases by 4 at every iteration

            // calling function that generates an array containing a single block of 3 trials (visualization 1, visualization 2, choice)
            let currentBlockOfTrialsArray_part1 = generateBlockOfFamiliarizationTrials(1, index, taskFamiliarizationObject_part1)

            // creating the feedback trial and adding it to the array
            let feedback_trial = {
                type: jsPsychImageKeyboardResponse,
                stimulus: `tutorial/${currentExperiment.pCorrectionType}/task_familiarization_images/part 1/${taskFamiliarizationObject_part1[index + 4][3]}.PNG`,
                prompt: "", //defined below based on correctness of choice
                choices: [' '],
                stimulus_height: window.innerHeight / 1.5,
                // using a closure (a function that has access to the variables defined in its outer function) to be able to access "index" from inside the on_start function
                on_start: (function (index) {
                    return function (currentFeedbackTrial) {
                        // accessing last trial:
                        let last_trial = jsPsych.data.get().last(1).values()[0];
                        // changing prompt according to correctness of last choice:
                        if (last_trial.response == taskFamiliarizationObject_part1[index + 4][0].toLowerCase()) {
                            currentFeedbackTrial.prompt = `<br><br> ${taskFamiliarizationObject_part1[index + 4][1]}`;
                        } else {
                            currentFeedbackTrial.prompt = `<br><br> ${taskFamiliarizationObject_part1[index + 4][2]}`;
                        }
                    };
                })(index)
            };
            currentBlockOfTrialsArray_part1.push(feedback_trial)

            // adding all the elments of the array to the timeline
            currentBlockOfTrialsArray_part1.forEach(singleTrial => {
                timeline.push(singleTrial)
            });

        }


        // PART 2: WITH BACKGROUND INFORMATION
        // PRELOADING images:
        // calling function to create filepaths for all images
        let taskFamiliarization2_ImagesArray = createArrayOfFilePaths(taskFamiliarizationObject_part2, 2)
        // adding preload plugin to timeline
        let preloadTaskFamiliarization2 = {
            type: jsPsychPreload,
            images: taskFamiliarization2_ImagesArray,
        }
        timeline.push(preloadTaskFamiliarization2)

        // creating the trials for the second part of the task familiarization        
        for (let index = 0; index < Object.keys(taskFamiliarizationObject_part2).length; index += 4) {
            // NB: index increases by 4 at every iteration

            // calling function that generates an array containing a single block of 3 trials (visualization 1, visualization 2, choice)
            let currentBlockOfTrialsArray_part2 = generateBlockOfFamiliarizationTrials(2, index, taskFamiliarizationObject_part2)

            // creating the feedback trial and adding it to the array
            let feedback_trial = {
                type: jsPsychImageKeyboardResponse,
                stimulus: "", //defined below based on correctness of choice
                prompt: "", //defined below based on correctness of choice
                choices: [' '],
                // stimulus_width: (SPECIFY IF NECESSARY)
                stimulus_height: window.innerHeight / 1.5,
                // using a closure (a function that has access to the variables defined in its outer function) to be able to access "index" from inside the on_start function
                on_start: (function (index) {
                    return function (currentFeedbackTrial) {
                        // accessing second to last trial:
                        let second_to_last_trial = jsPsych.data.get().last(1).values()[0];
                        // changing prompt according to correctness of last choice:
                        if (second_to_last_trial.response == taskFamiliarizationObject_part2[index + 4][0].toLowerCase()) {
                            currentFeedbackTrial.stimulus = `tutorial/${currentExperiment.pCorrectionType}/task_familiarization_images/part 2/${taskFamiliarizationObject_part2[index + 4][3]}.PNG`;
                            currentFeedbackTrial.prompt = `<br><br> ${taskFamiliarizationObject_part2[index + 4][1]}`;
                        } else {
                            currentFeedbackTrial.stimulus = `tutorial/${currentExperiment.pCorrectionType}/task_familiarization_images/part 2/${taskFamiliarizationObject_part2[index + 4][4]}.PNG`;
                            currentFeedbackTrial.prompt = `<br><br> ${taskFamiliarizationObject_part2[index + 4][2]}`;
                        }
                    };
                })(index)
            };
            currentBlockOfTrialsArray_part2.push(feedback_trial)

            // adding all the elments of the array to the timeline
            currentBlockOfTrialsArray_part2.forEach(singleTrial => {
                timeline.push(singleTrial)
            });
        }

        /* EXPERIMENT STRUCTURE IMAGE */
        // PRELOADING experiment structure image:
        // adding preload plugin to timeline
        let preloadExpStructureImage = {
            type: jsPsychPreload,
            images: [`tutorial/experiment_structure_images/HUPLACLIP-structure_${currentExperiment.KGridScaling}.PNG`],
        }
        timeline.push(preloadExpStructureImage)

        // SHOWING experiment structure image:
        let experiment_structure_image = {
            type: jsPsychInstructions,
            pages: [`<font size="+2"><b> EXPERIMENT STRUCTURE</b></font><br>
                    <img src="tutorial/experiment_structure_images/HUPLACLIP-structure_${currentExperiment.KGridScaling}.PNG" alt="Could not upload image" height="${window.innerHeight / 2}"><br><br>
                    The experiment is divided in <b>6 blocks</b> of <b>${currentExperiment.numberOfPresentationsPerBlock} trials</b> each. The difficulty of the task will gradually increase as you progress through each block. 
                    There is no penalty in using shuffles, and you will have <b>${currentExperiment.maximumNumberOfShuffles} shuffles for each trial</b>. 
                    Remember that you can use them, especially in harder trials. There is no time limit for completing the task.<br>
                    The experiment includes audio feedback, so please make sure your device has sound turned on if possible.<br><br>
                    <i><b>Press right arrow to START THE EXPERIMENT. ></b></i>`],
            key_forward: "ArrowRight",
            on_finish: function () {
                // Select the element with class "jspsych-display-element"
                var displayElement = document.querySelector('.jspsych-display-element');
                // Add the style attribute with overflow:hidden to prevent subject from scrolling during experiment
                displayElement.style.overflow = 'hidden';
            }            
        }
        timeline.push(experiment_structure_image)


        /* CONTROLLING THAT FILES HAVE BEEN SUCCESSFULLY LOADED */
        //NB: will only be visualized if graphs have not been loaded yet
        // loading page:
        var loading_page = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: 'Please wait while the experiment is loading...<br><br> (This could take a few minutes, if you are on a slow connection)',
            trial_duration: 1000  //brief presentation (1") so that the loop condition is evaluated continuously
        }
        // loop node:
        let loop_node = {
            timeline: [loading_page],
            loop_function: function () {
                // while currentExperiment.graphsToDisplay has not been completely populated, present the loading page:
                if (!(currentExperiment.hasOwnProperty('graphsToDisplay'))) {
                    console.log("graphs still loading")
                    return true
                }
                else {
                    return false
                }
            }
        }
        // loading completed page:
        var post_loading_page = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: 'Experiment has finished loading.<br><br>Press <b>any key</b> to start.',
        }
        // adding the loop node to the timeline only if currentExperiment.graphsToDisplay has not been completely populated (otherwise it is skipped)
        var if_node = {
            timeline: [loop_node, post_loading_page],
            conditional_function: function () {
                if (!(currentExperiment.hasOwnProperty('graphsToDisplay'))) {
                    return true;
                } else {
                    return false;
                }
            }
        };
        timeline.push(if_node);

        /* ENTERING FULLSCREEN (and disabling scrolling) */
        var enter_fullscreen = {
            type: jsPsychFullscreen,
            fullscreen_mode: true,
            message: `<p>The experiment will switch to full screen mode when you press the button below</p><br>`,
            on_start: function () {
                // Select the element with class "jspsych-display-element"
                var displayElement = document.querySelector('.jspsych-display-element');
                // Add the style attribute with overflow:hidden to prevent subject from scrolling during experiment
                displayElement.style.overflow = 'hidden';
            }
        }
        timeline.push(enter_fullscreen)        

        /* ACTUAL EXPERIMENT: */

        /* DRAWING STIMULI: */
        // FUNCTION THAT WILL DRAW THE STIMULI GIVEN THE CHOSEN ORDER OF THE NODES:
        function generateDrawCanvas(blockIndex, presentationIndex) {
            /* INPUT: 
            - blockIndex (the number that identifies the current block)
            - presentationIndex (the number that identifies the couple of graphs that is being displayed)
 
            OUTPUT:
            - display of the stimuli on the screen
            */

            // function that generates the stimuli:
            function drawCanvas(c) {

                // calling resizing canvas function:
                resizeCanvas(c);

                // addressing canvas
                let ctx = c.getContext("2d");

                // disable smoothing:
                ctx.imageSmoothingEnabled = false

                // for each presentation, shuffling the standard order of the nodes:
                let currentTrialOrder = shuffleNodes(currentExperiment.standardOrderOfNodes.slice()).slice(0, currentExperiment.graphSize);

                // accessing the array of the trials completed up to now (used to draw the feedback):
                let currentTrialsArray = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" }).trials;

                // DRAWING ON CANVAS:
                // - wrapping each function call in a promise
                let drawStimulusLeftPromise = new Promise((resolve) => {
                    drawStimulus("left", ctx, blockIndex, presentationIndex, currentTrialOrder);
                    resolve();
                });

                let drawStimulusRightPromise = new Promise((resolve) => {
                    drawStimulus("right", ctx, blockIndex, presentationIndex, currentTrialOrder);
                    resolve();
                });

                let drawDiagonalPromise = new Promise((resolve) => {
                    drawDiagonal(ctx);
                    resolve();
                });

                let drawFeedbackPromise = new Promise((resolve) => {
                    drawFeedback(ctx, blockIndex, presentationIndex, currentTrialsArray);
                    resolve();
                });

                let drawInstructionsReminderPromise = new Promise((resolve) => {
                    drawInstructionsReminder(ctx);
                    resolve();
                });

                // - executing all the promises in parallel and storing variables:
                return Promise.all([
                    drawStimulusLeftPromise,
                    drawStimulusRightPromise,
                    drawDiagonalPromise,
                    //drawFeedbackPromise,
                    //drawInstructionsReminderPromise
                ]).then(() => {
                    // - order of the nodes (changes from trial to trial and is read in "my-plugin-canvas-keyboard-response.js")
                    jsPsych.data.presentedOrder = currentTrialOrder;
                    // - correct answer (its value is read to compute the "correct" variable, does not change from trial to trial but is read to compute "correct" variable from plugin)
                    if (currentExperiment.graphsToDisplay[blockIndex][presentationIndex][0][currentExperiment.graphSize].clique_array === "clique is absent") {
                        // if the first stimulus doesn't have the clique, then the graph with the clique (correct answer) is on the right side
                        jsPsych.data.correctResponse = "arrowright";
                    } else {
                        jsPsych.data.correctResponse = "arrowleft";
                    }
                });

            }

            return drawCanvas

        }


        // Creating feedback audio trials (will be added to timeline after each trial):
        var feedbackAudio = {
            type: jsPsychAudioKeyboardResponse,
            stimulus: function () {
                // defining stimulus based on last response (shuffle, correct answer, wrong answer)
                let lastTrial = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" }).last(1).values()[0]
                if (lastTrial.response == " ")
                    return 'audio_feedback/shuffles/shuffle.mp3';
                else
                    if (lastTrial.correct)
                        return 'audio_feedback/right/right.mp3'
                    else
                        return 'audio_feedback/wrong/wrong.mp3'
            },
            choices: "NO_KEYS",
            trial_ends_after_audio: true,
            response_allowed_while_playing: false,
        };


        // creating the blocks of the experiment
        for (let blockIndex = 0; blockIndex < currentExperiment.numberOfBlocks; blockIndex++) {

            // creating the trials for the block
            for (let presentationIndex = 0; presentationIndex < currentExperiment.numberOfPresentationsPerBlock; presentationIndex++) {

                // defining the current trial
                let currentTrial = {
                    type: jsPsychCanvasKeyboardResponse,
                    canvas_size: [currentExperiment.canvasDimensions[0], currentExperiment.canvasDimensions[1]], // LOGICAL COORDINATES [height,width]
                    choices: [' ', 'ArrowLeft', 'ArrowRight'],
                    response_ends_trial: true,
                    // adding the stimuli and the audio feedback to the timeline of the trial
                    timeline: [{ stimulus: generateDrawCanvas(blockIndex, presentationIndex) }, feedbackAudio],     // NB: shuffling of nodes is done inside draw function
                    data: {
                        // storing variables that do not change between trials relative to the same couple of graphs
                        // experiment parameters:
                        block_index: blockIndex,
                        presentation_index: presentationIndex,
                        // graphs parameters:
                        clique_size: currentExperiment.arrayOfCliqueSizes[presentationIndex],
                        graph_size: currentExperiment.graphSize,
                    },

                    on_start: function (currentTrial) {
                        // - when trial starts, graphs have been read:
                        currentTrial.data.graphs_names = [currentExperiment.graphsToDisplay[blockIndex][presentationIndex][0][currentExperiment.graphSize].graph_name, currentExperiment.graphsToDisplay[blockIndex][presentationIndex][1][currentExperiment.graphSize].graph_name]
                        // - accessing the data stored up to now (it will increase progressively):
                        let currentData = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" })
                        // - if no more shuffles are available, only allowing final answers (arrow presses):
                        if (currentData.trials.filter(element => element.block_index == blockIndex && element.presentation_index == presentationIndex).length == currentExperiment.maximumNumberOfShuffles)
                            currentTrial.choices = ['ArrowLeft', 'ArrowRight']
                    },

                    // PRINT OF DATA AFTER EACH RESPONSE, FOR CONTROL/DEBUGGING PURPOSES:
                    /*
                    on_finish: function (data) {

                        let currentData = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" })
                        console.log(currentData)

                    },
                    */
                }

                // repeating the trial until a final answer (left/right arrow press) is given:
                let loop_node = {
                    timeline: [currentTrial],
                    loop_function: function () {
                        // isolating the canvas keyboard responses stored up to now (they will increase progressively):
                        let currentData = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" })
                        //currentData.trials.filter(element => element.)
                        if (currentData.last(1).values()[0].response == " ") {
                            // if last response was a spacebar press, repeat the trial
                            //console.log("shuffle pressed, repeating trial")
                            return true
                        } else if (currentData.last(1).values()[0].response == 0 || currentData.last(1).values()[0].response == 1) {
                            //console.log("final response, going on")
                            // if last response was on left/right arrow, moving to next trial
                            return false
                        }

                    }
                }

                // adding the loop node to the timeline
                timeline.push(loop_node)

            }

            // after each block, present break page
            switch (blockIndex) {
                // if last block just presented, final page will be different
                case (currentExperiment.numberOfBlocks - 1):
                    /* FINAL PAGE */
                    let final_page = {
                        type: jsPsychInstructions,
                        pages: [], // defined inside on_start function (below)
                        key_forward: " ",
                        on_start: function (final_page) {
                            // accessing the array of all the trials completed up to now:
                            let currentTrialsArray = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" }).trials
                            let arrayOfResponsesLastBlock = []  //to compute block score
                            let arrayOfResponses = []   //to compute total score
                            currentTrialsArray.forEach(element => {
                                // creating array of final responses for current block:
                                if (element.block_index == blockIndex && element.hasOwnProperty('correct'))
                                    arrayOfResponsesLastBlock.push(element.correct)
                                // creating array of all final responses:
                                if (element.hasOwnProperty('correct'))
                                    arrayOfResponses.push(element.correct)
                            })
                            // computing score:
                            // - last block score:
                            let numberOfCorrectResponsesLastBlock = arrayOfResponsesLastBlock.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponsesLastBlock = arrayOfResponsesLastBlock.length
                            // - total score:
                            let numberOfCorrectResponses = arrayOfResponses.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponses = arrayOfResponses.length
                            // last trial feedaback: changing background color of SCORE based on correctness of last response
                            let scoreColor = "black"
                            if (arrayOfResponsesLastBlock[arrayOfResponsesLastBlock.length - 1]) {
                                scoreColor = "lawngreen"
                            } else {
                                scoreColor = "red"
                            }
                            // change final message if experiment is running on pavlovia.org:
                            let message = `Press <b>space</b> to exit.`
                            if (document.location.hostname == "run.pavlovia.org") {
                                message = `
                                <p style="color: red"><strong>DON'T CLOSE THIS WINDOW YET!</strong></p>
                                After you press <b>space</b>, please <b>wait until you are redirected to Prolific</b>.<br>
                                If you get a pop-up warning you "data may not be saved", you can click "leave", your data have already been saved.
                                `
                            }
                            final_page.pages = [
                                `<p> 
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:${scoreColor};color:black;display:inline-block;">SCORE: ${numberOfCorrectResponsesLastBlock} / ${numberOfFinalResponsesLastBlock}</div>
                                <br><br><br>                             
                                You completed all the <b> ${currentExperiment.numberOfBlocks}</b> blocks of the experiment. <br><br>
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:gold;color:black;display:inline-block;">TOTAL SCORE: ${numberOfCorrectResponses} / ${numberOfFinalResponses}</div>
                                <br><br><br>
                                ${message}<br><br>
                                Thank you for your time.                         
                                </p>`]
                        }
                    };
                    timeline.push(final_page)
                    break;
                default:
                    /* AGREEMENT TO MOVE TO NEXT BLOCK */
                    let move_to_next_block = {
                        type: jsPsychInstructions,
                        pages: [], // defined inside on_start function (below)
                        key_forward: " ",
                        on_start: function (move_to_next_block) {
                            // accessing the array of the trials completed up to now:
                            let currentTrialsArray = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" }).trials
                            let arrayOfResponsesPerBlock = []
                            currentTrialsArray.forEach(element => {
                                // creating array of final responses for current block:
                                if (element.block_index == blockIndex && element.hasOwnProperty('correct'))
                                    arrayOfResponsesPerBlock.push(element.correct)
                            })
                            // calculating accuracy for current block:
                            let numberOfCorrectResponsesPerBlock = arrayOfResponsesPerBlock.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponsesPerBlock = arrayOfResponsesPerBlock.length
                            // last trial feedback: changing background color of SCORE based on correctness of last response
                            let scoreColor = "black"
                            if (arrayOfResponsesPerBlock[arrayOfResponsesPerBlock.length - 1]) {
                                scoreColor = "lawngreen"
                            } else {
                                scoreColor = "red"
                            }
                            move_to_next_block.pages = [
                                `<p> 
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:${scoreColor};color:black;display:inline-block;">SCORE: ${numberOfCorrectResponsesPerBlock} / ${numberOfFinalResponsesPerBlock}</div>
                                    <br><br>
                                    So far, you have completed <b> ${(blockIndex + 1)} </b> out of <b>${currentExperiment.numberOfBlocks}</b> blocks. <br>
                                    You still have <b> ${currentExperiment.numberOfBlocks - (blockIndex + 1)} </b> to go.
                                    <br><br>
                                    Remember: <br>
                                    - Press <b> LEFT / RIGHT arrow </b> to choose the triangle with the hidden red tiles. <br>
                                    - Press <b> SPACE </b> to shuffle the triangles. <br><br>
                                    When you feel ready, press <b>space</b> to move to the next block.
                                  </p>`]
                        }
                    };
                    timeline.push(move_to_next_block)
            }

        }

        /* EXITING FULLSCREEN (and re-enabling scrolling) */
        var exit_fullscreen = {
            type: jsPsychFullscreen,
            fullscreen_mode: false,
            delay_after: 0,
            on_start: function () {
                // Select the element with class "jspsych-display-element"
                var displayElement = document.querySelector('.jspsych-display-element');
                // Remove the style attribute with overflow:hidden to allow scrolling
                displayElement.style.overflow = 'auto';
            }          
        }
        timeline.push(exit_fullscreen)

        /* finish connection with pavlovia.org */
        if (document.location.hostname == "run.pavlovia.org"){
            /* finish connection with pavlovia.org */
            var pavlovia_finish = {
                type: jsPsychPavlovia,
                command: "finish",
                participantId:  jsPsych.data.getURLVariable('PROLIFIC_PID'),                
                on_finish: function (){
                    document.body.innerHTML = `<p> Please wait. You will be redirected back to Prolific in a few moments. 
                    If you get a pop-up warning you "data may not be saved", you can click "leave", your data have already been saved.</p>`;
                    setTimeout(function () {
                      location.href = `https://www.google.com/`;
                      document.body.innerHTML =`<p>If you are not automatically redirected, please click here: 
                      <a href="https://www.google.com/">https://www.google.com/</a></p>
                      <p>If you get a pop-up warning you "data may not be saved", you can click "leave", your data have already been saved.</p>`;
                    }, 5000);
                  }
            };
            timeline.push(pavlovia_finish);
        }           

        /* start the experiment */
        jsPsych.run(timeline);

    </script>

</body>

</html>