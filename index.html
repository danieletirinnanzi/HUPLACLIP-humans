<!DOCTYPE html>
<html>

<head>
    <title>HUPLACLIP experiment</title>
    <!-- My scripts -->
    <!-- <script type="text/javascript" src="device_requirements.js"></script> -->
    <script type="text/javascript" src="graphs_functions.js"></script>
    <script type="text/javascript" src="introduction_pages_generation.js"></script>
    <script type="text/javascript" src="tutorial/tutorial_pages_generation.js"></script>
    <script type="text/javascript" src="experiment_parameters.js"></script>
    <script type="text/javascript" src="canvas_drawing.js"></script>
    <!-- Standard jspsych.js -->
    <script type="text/javascript" src="plugins/standard_plugins/jspsych.js"></script>
    <!-- Standard plugins -->
    <script type="text/javascript" src="plugins/standard_plugins/plugin-instructions.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-fullscreen.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-image-keyboard-response.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-survey-html-form.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-html-keyboard-response.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-preload.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/plugin-audio-keyboard-response.js"></script>
    <!-- Customized plugin -->
    <script type="text/javascript" src="plugins/my-plugin-canvas-keyboard-response.js"></script>  
    <!-- Call function plugin (standard) -->
    <script src="https://unpkg.com/@jspsych/plugin-call-function@1.1.3"></script>
    <!-- Browser check plugin (stanard) -->
    <script src="https://unpkg.com/@jspsych/plugin-browser-check@1.0.3"></script>    
    <!-- Compressing and de-compressing json files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.11/pako.min.js"></script>
    <!-- Pavlovia connection (COMMENTED FOR OFFLINE VERSION)
    <script type="text/javascript" src="lib/vendors/jquery-2.2.0.min.js"></script>
    <script type="text/javascript" src="plugins/standard_plugins/my-pavlovia.js"></script>
    -->
    <!-- Styling -->
    <link href="plugins/standard_plugins/jspsych.css" rel="stylesheet" type="text/css" />
</head>

<style>
    /* styling can be modified here */
</style>

<body>

    <script type="module">

        // Function to read a compressed file and return a Promise
        function readCompressedGraphFile(url) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.responseType = 'arraybuffer';

                xhr.onload = function () {
                    if (xhr.status === 200) {
                        // File successfully loaded
                        const compressedData = new Uint8Array(xhr.response);

                        // Decompress the data using pako
                        const decompressedData = pako.inflate(compressedData, { to: 'string' });

                        // Parse the decompressed JSON data
                        const graph = JSON.parse(decompressedData);
                        resolve(graph);
                    } else {
                        // File loading failed
                        reject(new Error(`Failed to load file: ${url}`));
                    }
                };

                xhr.onerror = function () {
                    reject(new Error(`Failed to load file: ${url}`));
                };

                xhr.open('GET', url, true);
                xhr.send();
            });
        }

        // Async function to read the graph files
        async function readGraphFiles() {

            /* extract indices of graphs to display */
            let graphsWithCliqueIndices = extractIndices()
            let graphsWithoutCliqueIndices = extractIndices()

            /* generating names of graphs to display and storing them in currentExperiment object  */
            // empty array that will contain the couples of triangular matrices (objects) to be displayed
            let graphsToDisplay = [];

            // number of blocks:
            for (let blockIndex = 0; blockIndex < currentExperiment.numberOfBlocks; blockIndex++) {

                let graphsForCurrentBlock = []

                for (const element of currentExperiment.uniqueCliqueSizes) {

                    // GRAPH WITH CLIQUE, trial 1:
                    // - creating URL:
                    let graphWithClique_trial1_url = `graph_pools/${currentExperiment.pCorrectionType}/N${currentExperiment.graphSize.toString().padStart(4, '0')}/CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithCliqueIndices[element][blockIndex * 2].toString().padStart(4, '0')}_N${currentExperiment.graphSize.toString().padStart(4, '0')}_K${element.toString().padStart(4, '0')}_CLIQUE.json`
                    // GRAPH WITHOUT CLIQUE, trial 1:
                    // - creating URL:            
                    let graphWithoutClique_trial1_url = `graph_pools/${currentExperiment.pCorrectionType}/N${currentExperiment.graphSize.toString().padStart(4, '0')}/NO_CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithoutCliqueIndices[element][blockIndex * 2].toString().padStart(4, '0')}_N${currentExperiment.graphSize.toString().padStart(4, '0')}_K${element.toString().padStart(4, '0')}_NOCLIQUE.json`

                    // Start reading the files in the background
                    const [graphWithClique1, graphWithoutClique1] = await Promise.all([
                        readCompressedGraphFile(graphWithClique_trial1_url),
                        readCompressedGraphFile(graphWithoutClique_trial1_url)
                    ]);

                    // Adding the two graphs to the array for the current trial (random choice of which one is the first in the couple) and pushing this array into the array relative to the current block
                    if (Math.round(Math.random())) {
                        graphsForCurrentBlock.push([graphWithClique1, graphWithoutClique1])
                    } else {
                        graphsForCurrentBlock.push([graphWithoutClique1, graphWithClique1])
                    }

                    // GRAPH WITH CLIQUE, trial 2:
                    // - creating URL:
                    let graphWithClique_trial2_url = `graph_pools/${currentExperiment.pCorrectionType}/N${currentExperiment.graphSize.toString().padStart(4, '0')}/CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithCliqueIndices[element][blockIndex * 2 + 1].toString().padStart(4, '0')}_N${currentExperiment.graphSize.toString().padStart(4, '0')}_K${element.toString().padStart(4, '0')}_CLIQUE.json`
                    // GRAPH WITHOUT CLIQUE, trial 2:
                    // - creating URL:            
                    let graphWithoutClique_trial2_url = `graph_pools/${currentExperiment.pCorrectionType}/N${currentExperiment.graphSize.toString().padStart(4, '0')}/NO_CLIQUE/${element.toString().padStart(4, '0')}/${graphsWithoutCliqueIndices[element][blockIndex * 2 + 1].toString().padStart(4, '0')}_N${currentExperiment.graphSize.toString().padStart(4, '0')}_K${element.toString().padStart(4, '0')}_NOCLIQUE.json`

                    // Start reading the files in the background
                    const [graphWithClique2, graphWithoutClique2] = await Promise.all([
                        readCompressedGraphFile(graphWithClique_trial2_url),
                        readCompressedGraphFile(graphWithoutClique_trial2_url)
                    ]);


                    // Adding the two graphs to the array for the current trial (random choice of which one is the first in the couple) and pushing this array into the array relative to the current block
                    if (Math.round(Math.random())) {
                        graphsForCurrentBlock.push([graphWithClique2, graphWithoutClique2])
                    } else {
                        graphsForCurrentBlock.push([graphWithoutClique2, graphWithClique2])
                    }
                }

                // adding array of graphs for current block to array of all graphs
                graphsToDisplay.push(graphsForCurrentBlock)

                console.log("finished reading graphs for block number: " + blockIndex)

            }

            console.log("finished reading graphs")
            // adding array of graphs to display to currentExperiment object:
            currentExperiment.graphsToDisplay = graphsToDisplay

            // Printing the currentExperiment object to the console
            console.log(currentExperiment)

        }


        /* initializing jspsych */
        var jsPsych = initJsPsych({

            // maximum width of experiment pages (logical coordinates)
            experiment_width: screen.width,

            // Audio will be played through HTML5, not through WebAudio API
            use_webaudio: false,

            // preloading files that can be automatically detected from the timeline:
            auto_preload: true,

            on_finish: function (data) {
                // displaying data:
                jsPsych.data.displayData();
                /* LOCAL SAVE DONE AUTOMATICALLY IN PILOT MODE
                //local save:
                let currentDate = new Date();
                let fileName = `HUPLACLIP_pilot_${currentDate.getDate()}.${(currentDate.getMonth() + 1)}.${currentDate.getFullYear()}_${currentDate.getHours()}.${currentDate.getMinutes()}.${currentDate.getSeconds()}.csv`
                jsPsych.data.get().localSave('csv', fileName);
                */
            }
        });


        /* create timeline */
        let timeline = [];

        /* CHECKING DEVICE/BROWSER REQUIREMENTS */

        //NOTE: logic (it should be working on Safari as well)
        // 1. browser-check 1 -> checking if full-screen is supported and if the device is not mobile;
        // 2. calling function to retrieve vertical resolution of device, checking its validity and storing it in the currentExperiment object;

        // TODO: 
        // - check that it works on Safari as well
        // - ADD LINK TO PROLIFIC IN THE RETURN TO PROLIFIC LINKS

        // 1. browser-check 1 (checking that full-screen is supported and that device is not mobile)        
        var browser_check = {
            type: jsPsychBrowserCheck,
            inclusion_function: (data) => {               
                return data.mobile === false && data.fullscreen === true; 
                },
            exclusion_message: (data) => {
                if(data.mobile){
                    return `<p>You must use a <b>desktop/laptop computer</b> to participate in this experiment.</p><br>
                            Click the button below to be redirected to Prolific:
                            <button style="font-size: 18px; padding: 10px 20px;" onclick="window.location.href='https://google.com'">Return to Prolific</button>
                            <br> <br>
                            <p style="font-size: 15px;">To report any issues, please contact the experimenter at <a href="mailto:dtirinna@sissa.it">dtirinna@sissa.it</a></p>
                            `;
                } else if(data.fullscreen === false){
                    return `<p>Your current browser does not support Fullscreen, please <b>open the experiment with a different browser</b>.</p><br>
                            Click the button below to be redirected to Prolific:
                            <button style="font-size: 18px; padding: 10px 20px;" onclick="window.location.href='https://google.com'">Return to Prolific</button>
                            <br> <br>
                            <p style="font-size: 15px;">To report any issues, please contact the experimenter at <a href="mailto:dtirinna@sissa.it">dtirinna@sissa.it</a></p>
                            `;
                }
            },
        }
        timeline.push(browser_check) 

        // 2. function to retrieve vertical resolution of device, checking its validity and storing it in the currentExperiment object;
        var device_check = {
            type: jsPsychCallFunction,
            func: function () {
                // - calling function to retrieve the physical screen dimensions
                let physicalScreenDimensions = {
                    width: window.screen.width * window.devicePixelRatio | 0,
                    height: window.screen.height * window.devicePixelRatio | 0
                };
                
                // TO REMOVE
                console.log("True Physical Screen Width:", physicalScreenDimensions.width);
                console.log("True Physical Screen Height:", physicalScreenDimensions.height);

                // - defining valid vertical resolutions based on the graph size:
                // NOTE: the list of vertical resolutions is needed because if the browser's zoom is not set to 100%, the retrieved resolution might be different from the physical one
                switch (currentExperiment.graphSize) {
                    case 100:
                    case 150:
                    case 200:
                    case 300:
                    case 400:
                    case 480:
                    case 600:
                        var validVerticalResolutions = [720, 768, 864, 900, 1024, 1050, 1080, 1152, 1200, 1344, 1392, 1400, 1440, 1536, 1600, 1664, 1800, 1824, 1864, 1920, 1964, 2160, 2234, 2304, 2400, 2520, 2880, 3384];
                        break;
                    case 800:
                        var validVerticalResolutions = [864, 900, 1024, 1050, 1080, 1152, 1200, 1344, 1392, 1400, 1440, 1536, 1600, 1664, 1800, 1824, 1864, 1920, 1964, 2160, 2234, 2304, 2400, 2520, 2880, 3384];
                        break;
                    case 1000:
                        var validVerticalResolutions = [1024, 1050, 1080, 1152, 1200, 1344, 1392, 1400, 1440, 1536, 1600, 1664, 1800, 1824, 1864, 1920, 1964, 2160, 2234, 2304, 2400, 2520, 2880, 3384];
                        break;
                    default:
                        alert("Invalid graph size. Accepted graph size values for human experiments are: 100, 150, 200, 300, 400, 480, 600, 800, 1000.");
                        break;
                }                
                
                // - if dimension of single square is < 1 pixel, asking user to set zoom to 100%
                // number of squares to be drawn in the two directions (2 squares are for the diagonal):
                let numberOfSquares = currentExperiment.graphSize + 2
                // resulting square side dimension
                let squareSideDimensionPhysical = Math.floor(physicalScreenDimensions.height / numberOfSquares)                

                // checking if the vertical resolution is valid
                if (validVerticalResolutions.includes(physicalScreenDimensions.height) && squareSideDimensionPhysical >= 1) {
                    // valid resolution -> storing it in the currentExperiment object
                    currentExperiment.screenWidth = physicalScreenDimensions.width;
                    currentExperiment.screenHeight = physicalScreenDimensions.height;
                    //- calling function to calculate drawing parameters and storing them in the currentExperiment object:
                    currentExperiment.fixedDrawingParameters = calculateFixedDrawingParameters(physicalScreenDimensions.width, physicalScreenDimensions.height, currentExperiment.graphSize);
                    //- calling function to calculate coordinates of left and right triangles and storing them in the currentExperiment object:
                    let leftAndRightTriangleCoordinates = calculateTrianglesCoordinates(currentExperiment.fixedDrawingParameters, currentExperiment.graphSize);
                    currentExperiment.stimuliCoordinates = {};
                    currentExperiment.stimuliCoordinates.leftTriangle = leftAndRightTriangleCoordinates[0];
                    currentExperiment.stimuliCoordinates.rightTriangle = leftAndRightTriangleCoordinates[1];             
                    return; // Stop further execution
                } else {
                    // invalid resolution -> redirect to Prolific
                    document.body.innerHTML = `
                    <div style="text-align: left; margin-top: 50px;">
                        <p>If you are reading this message, make sure to:

                            <ul>
                                <li><b>Set your browser zoom to 100%</b> (you can change it in the browser options or by pressing "Ctrl +" / "Ctrl -" (Windows) or "⌥ ⌘ =" / "⌥ ⌘ -" (Mac) ) and click on the "Reload Page" button below. The page will reload and this page should not be shown anymore.</p></li>
                                <button style="font-size: 18px; padding: 10px 20px;" onclick="window.location.reload()">Reload Page</button><br><br>

                                <li>If you have set you browser zoom to 100% but this message does not disappear, you <b>might be using an incompatible device</b>. A vertical resolution of at least <b>${validVerticalResolutions[0]}</b> is required to run the experiment (you can check the resolution of your device in the device settings). If your current device does not meet this requirement, please open the experiment on a device with a higher vertical resolution.<br>
                                    Click the button below to be redirected to Prolific:</li>
                                <button style="font-size: 18px; padding: 10px 20px;" onclick="window.location.href='https://google.com'">Return to Prolific</button>
                            </ul>

                        <p><strong></strong></p>
                        <br>
                        <p style="font-size: 15px;">To report any issues, please contact the experimenter at <a href="mailto:dtirinna@sissa.it">dtirinna@sissa.it</a></p>
                    </div>
                `;                       
                }
            }
        }
        timeline.push(device_check)

        // PRELOADING feedback audio files:
        let preloadAudioFiles = {
            type: jsPsychPreload,
            audio: ['audio_feedback/shuffles/shuffle01.mp3', 'audio_feedback/right/coin01.mp3', 'audio_feedback/wrong/error01.mp3'],
        }
        timeline.push(preloadAudioFiles)              


        /* init connection with pavlovia.org */
        if (document.location.hostname == "run.pavlovia.org"){
            var pavlovia_init = {
                type: jsPsychPavlovia,
                command: "init"
            };
            timeline.push(pavlovia_init);
          }   


        /* INTRODUCTIVE PAGES */
        // showing informative pages about the study (informed consent, aim, privacy)
        let introduction = {
            type: jsPsychInstructions,
            pages: generateIntroductionPages(),
            key_forward: "ArrowRight",
            // call the readGraphFiles function when introduction pages are read:
            on_start: readGraphFiles
        }
        timeline.push(introduction)


        /* CONSENT FORM (for Prolific integration, new version) */
        // standard consent form
        var consent1 = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus:
              `By accepting to participate in this study, you confirm:
                <p style=\'text-align:left\'>
                    - That I have carefully read the explanations regarding this study and the entire experimental procedure;<br>
                    - That I have been informed about the aims and objectives of this research;<br>
                    - That I am aware of the inconveniences, if any, caused by the experiment;<br>
                    - That I have received satisfactory assurances regarding the confidentiality of the information obtained from the examination of my own person; <br>
                    - That I am aware that I can withdraw at any stage of the study.
                <p>
                <span style="color: #808080">
                    Press [Y] to <strong>accept</strong>.
                </span> <br>
                <span style="color: #808080">
                    Press [N] to <strong>refuse</strong>.
                </span>`,
            choices: ["Y", "N"],
          };
    
        // conditional consent form ( to be shown only if subject answers "N" to the first consent form):
        // - consent form content
        var consent2 = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus:
            `Do you confirm you refuse to go on?
            <p> 
                By pressing [Y], you will end the experiment <strong>without reward</strong> and will be redirected to Prolific.<br>
                By pressing [N] you will be redirected to the <strong>informed consent</strong> to read again the informations and accept the conditions.
            <p>
                <span style="color: #808080">Press [Y] to <strong>end the experiment</strong>.</span> <br>
                <span style="color: #808080">Press [N] to <strong>go back to the informed consent page</strong>.</span>`,
        choices: ["Y", "N"],
        on_finish: function (data) {
            if (data.response == "y") {
            // subject refuses to go on, redirect to Prolific
            window.location.replace(
                // TODO: ADD REFUSE CODE IN THE URL BELOW 
                "https://app.prolific.co/submissions/complete?cc=XXXXXX"
            );
            }
        },
        };
        // - conditional function
        var conditional_consent = {
        timeline: [consent2],
        conditional_function: function (data) {
            if (jsPsych.data.get().last(1).values()[0].response == "n") {
            return true;
            } else {
            return false;
            }
        },
        };
        // - loop node (keep showing standard consent form if the subject does not confirm he/she wants to exit the experiment)
        var loop_consent = {
        timeline: [consent1, conditional_consent],
        loop_function: function (data) {
            if (jsPsych.data.get().last(1).values()[0].response == "n") {
            return true;
            } else {
            return false;
            }
        },
        };  
        timeline.push(loop_consent)

        /* COLLECTING DEMOGRAPHIC DATA: */
        var demographic_survey = {
            type: jsPsychSurveyHtmlForm,
            preamble: '<p>Please answer the following questions:</p>',
            html: `
            <label for="gender">Indicate your gender:</label>
            <select id="gender" name="gender" required>
                <option value="" disabled selected>Select an option</option>
                <option value="male">Male</option>
                <option value="female">Female</option>
                <option value="transgender">Transgender</option>
                <option value="other">Other</option>
                <option value="not-specified">Prefer not to say</option>
            </select>
            <br><br><br>
            <label for="age">Indicate your age:</label>
            <input type="number" id="age" name="age" required>
            <br><br>
            After submitting a response, you will see the instructions for the experiment.
             <br><br>
            `
        };
        timeline.push(demographic_survey)        

        /* INSTRUCTIONS */
        // PRELOADING instructions images:
        // calling function to create filepaths for all instructions images
        let instructions_ImagesArray = createArrayOfFilePaths(instructionsObject, 0)
        // adding preload plugin to timeline
        let preloadInstructions = {
            type: jsPsychPreload,
            images: instructions_ImagesArray,
        }
        timeline.push(preloadInstructions)

        // SHOWING instructions:
        let instructions = {
            type: jsPsychInstructions,
            pages: generateInstructionsPages(),
            key_forward: "ArrowRight",
        }
        timeline.push(instructions)



        /* AGREEMENT TO MOVE TO TASK FAMILIARIZATION */
        let move_to_familiarization_form = {
            type: jsPsychInstructions,
            pages: [`<p> Now it's your turn! <br>
                From this moment on, you will not be able to move back and forth through the pages. <br><br>
                Press <b>space</b> to start a <b>trial run of the experiment</b>.<br> (for now, your score will not be recorded) <br>
                </p>`],
            key_forward: " "
        };
        timeline.push(move_to_familiarization_form)



        /* TASK FAMILIARIZATION */
        // PART 1: WITHOUT BACKGROUND INFORMATION
        // PRELOADING images:
        // calling function to create filepaths for all images
        let taskFamiliarization1_ImagesArray = createArrayOfFilePaths(taskFamiliarizationObject_part1, 1)
        // adding preload plugin to timeline
        let preloadTaskFamiliarization1 = {
            type: jsPsychPreload,
            images: taskFamiliarization1_ImagesArray,
        }
        timeline.push(preloadTaskFamiliarization1)

        // creating the trials for the first part of the task familiarization        
        for (let index = 0; index < Object.keys(taskFamiliarizationObject_part1).length; index += 4) {
            // NB: index increases by 4 at every iteration

            // calling function that generates an array containing a single block of 3 trials (visualization 1, visualization 2, choice)
            let currentBlockOfTrialsArray_part1 = generateBlockOfFamiliarizationTrials(1, index, taskFamiliarizationObject_part1)

            // creating the feedback trial and adding it to the array
            let feedback_trial = {
                type: jsPsychImageKeyboardResponse,
                stimulus: `tutorial/${currentExperiment.pCorrectionType}/task_familiarization_images/part 1/${taskFamiliarizationObject_part1[index + 4][3]}.PNG`,
                prompt: "", //defined below based on correctness of choice
                choices: [' '],
                stimulus_height: window.innerHeight / 1.5,
                // using a closure (a function that has access to the variables defined in its outer function) to be able to access "index" from inside the on_start function
                on_start: (function (index) {
                    return function (currentFeedbackTrial) {
                        // accessing last trial:
                        let last_trial = jsPsych.data.get().last(1).values()[0];
                        // changing prompt according to correctness of last choice:
                        if (last_trial.response == taskFamiliarizationObject_part1[index + 4][0].toLowerCase()) {
                            currentFeedbackTrial.prompt = `<br><br> ${taskFamiliarizationObject_part1[index + 4][1]}`;
                        } else {
                            currentFeedbackTrial.prompt = `<br><br> ${taskFamiliarizationObject_part1[index + 4][2]}`;
                        }
                    };
                })(index)
            };
            currentBlockOfTrialsArray_part1.push(feedback_trial)

            // adding all the elments of the array to the timeline
            currentBlockOfTrialsArray_part1.forEach(singleTrial => {
                timeline.push(singleTrial)
            });

        }


        // PART 2: WITH BACKGROUND INFORMATION
        // PRELOADING images:
        // calling function to create filepaths for all images
        let taskFamiliarization2_ImagesArray = createArrayOfFilePaths(taskFamiliarizationObject_part2, 2)
        // adding preload plugin to timeline
        let preloadTaskFamiliarization2 = {
            type: jsPsychPreload,
            images: taskFamiliarization2_ImagesArray,
        }
        timeline.push(preloadTaskFamiliarization2)

        // creating the trials for the second part of the task familiarization        
        for (let index = 0; index < Object.keys(taskFamiliarizationObject_part2).length; index += 4) {
            // NB: index increases by 4 at every iteration

            // calling function that generates an array containing a single block of 3 trials (visualization 1, visualization 2, choice)
            let currentBlockOfTrialsArray_part2 = generateBlockOfFamiliarizationTrials(2, index, taskFamiliarizationObject_part2)

            // creating the feedback trial and adding it to the array
            let feedback_trial = {
                type: jsPsychImageKeyboardResponse,
                stimulus: "", //defined below based on correctness of choice
                prompt: "", //defined below based on correctness of choice
                choices: [' '],
                // stimulus_width: (SPECIFY IF NECESSARY)
                stimulus_height: window.innerHeight / 1.5,
                // using a closure (a function that has access to the variables defined in its outer function) to be able to access "index" from inside the on_start function
                on_start: (function (index) {
                    return function (currentFeedbackTrial) {
                        // accessing second to last trial:
                        let second_to_last_trial = jsPsych.data.get().last(1).values()[0];
                        // changing prompt according to correctness of last choice:
                        if (second_to_last_trial.response == taskFamiliarizationObject_part2[index + 4][0].toLowerCase()) {
                            currentFeedbackTrial.stimulus = `tutorial/${currentExperiment.pCorrectionType}/task_familiarization_images/part 2/${taskFamiliarizationObject_part2[index + 4][3]}.PNG`;
                            currentFeedbackTrial.prompt = `<br><br> ${taskFamiliarizationObject_part2[index + 4][1]}`;
                        } else {
                            currentFeedbackTrial.stimulus = `tutorial/${currentExperiment.pCorrectionType}/task_familiarization_images/part 2/${taskFamiliarizationObject_part2[index + 4][4]}.PNG`;
                            currentFeedbackTrial.prompt = `<br><br> ${taskFamiliarizationObject_part2[index + 4][2]}`;
                        }
                    };
                })(index)
            };
            currentBlockOfTrialsArray_part2.push(feedback_trial)

            // adding all the elments of the array to the timeline
            currentBlockOfTrialsArray_part2.forEach(singleTrial => {
                timeline.push(singleTrial)
            });
        }

        /* EXPERIMENT STRUCTURE IMAGE */
        // PRELOADING experiment structure image:
        // adding preload plugin to timeline
        let preloadExpStructureImage = {
            type: jsPsychPreload,
            images: [`tutorial/experiment_structure_images/HUPLACLIP-structure.PNG`],
        }
        timeline.push(preloadExpStructureImage)

        // SHOWING experiment structure image:
        let experiment_structure_image = {
            type: jsPsychInstructions,
            pages: [`<font size="+2"><b> EXPERIMENT STRUCTURE</b></font><br>
                    <img src="tutorial/experiment_structure_images/HUPLACLIP-structure.PNG" alt="Could not upload image" height="${window.innerHeight / 2}"><br><br>
                    The experiment is divided in <b>6 blocks</b> of <b>30 trials</b> each. The difficulty of the task will gradually increase as you progress through each block. 
                    There is no penalty in using shuffles, and you will have <b>10 shuffles for each trial</b>. 
                    Remember that you can use them, especially in harder trials. There is no time limit for completing the task.<br>
                    If you can, raise the volume of your device: the experiment includes audio feedback.<br><br>
                    <i><b>Press right arrow to START THE EXPERIMENT. ></b></i>`],
            key_forward: "ArrowRight",
            on_finish: function () {
                // Select the element with class "jspsych-display-element"
                var displayElement = document.querySelector('.jspsych-display-element');
                // Add the style attribute with overflow:hidden to prevent subject from scrolling during experiment
                displayElement.style.overflow = 'hidden';
            }            
        }
        timeline.push(experiment_structure_image)


        /* CONTROLLING THAT FILES HAVE BEEN SUCCESSFULLY LOADED */
        //NB: will only be visualized if graphs have not been loaded yet
        // loading page:
        var loading_page = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: 'Please wait while the experiment is loading...<br><br> (This could take a few minutes, if you are on a slow connection)',
            trial_duration: 1000  //brief presentation (1") so that the loop condition is evaluated continuously
        }
        // loop node:
        let loop_node = {
            timeline: [loading_page],
            loop_function: function () {
                // while currentExperiment.graphsToDisplay has not been completely populated, present the loading page:
                if (!(currentExperiment.hasOwnProperty('graphsToDisplay'))) {
                    console.log("graphs still loading")
                    return true
                }
                else {
                    return false
                }
            }
        }
        // loading completed page:
        var post_loading_page = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: 'Experiment has finished loading.<br><br>Press <b>any key</b> to start.',
        }
        // adding the loop node to the timeline only if currentExperiment.graphsToDisplay has not been completely populated (otherwise it is skipped)
        var if_node = {
            timeline: [loop_node, post_loading_page],
            conditional_function: function () {
                if (!(currentExperiment.hasOwnProperty('graphsToDisplay'))) {
                    return true;
                } else {
                    return false;
                }
            }
        };
        timeline.push(if_node);

        /* ENTERING FULLSCREEN (and disabling scrolling) */
        var enter_fullscreen = {
            type: jsPsychFullscreen,
            fullscreen_mode: true,
            message: `<p>The experiment will switch to full screen mode when you press the button below</p><br>`,
            on_start: function () {
                // Select the element with class "jspsych-display-element"
                var displayElement = document.querySelector('.jspsych-display-element');
                // Add the style attribute with overflow:hidden to prevent subject from scrolling during experiment
                displayElement.style.overflow = 'hidden';
            }
        }
        timeline.push(enter_fullscreen)        

        /* ACTUAL EXPERIMENT: */

        /* DRAWING STIMULI: */
        // FUNCTION THAT WILL DRAW THE STIMULI GIVEN THE CHOSEN ORDER OF THE NODES:
        function generateDrawCanvas(blockIndex, presentationIndex) {
            /* INPUT: 
            - blockIndex (the number that identifies the current block)
            - presentationIndex (the number that identifies the couple of graphs that is being displayed)
 
            OUTPUT:
            - display of the stimuli on the screen
            */

            // function that generates the stimuli:
            function drawCanvas(c) {

                // calling resizing canvas function:
                resizeCanvas(c);

                // addressing canvas
                let ctx = c.getContext("2d");

                // disable smoothing:
                ctx.imageSmoothingEnabled = false

                // for each presentation, shuffling the standard order of the nodes:
                let currentTrialOrder = shuffleNodes(currentExperiment.standardOrderOfNodes.slice()).slice(0, currentExperiment.graphSize);

                // accessing the array of the trials completed up to now (used to draw the feedback):
                let currentTrialsArray = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" }).trials;

                // DRAWING ON CANVAS:
                // - wrapping each function call in a promise
                let drawStimulusLeftPromise = new Promise((resolve) => {
                    drawStimulus("left", ctx, blockIndex, presentationIndex, currentTrialOrder);
                    resolve();
                });

                let drawStimulusRightPromise = new Promise((resolve) => {
                    drawStimulus("right", ctx, blockIndex, presentationIndex, currentTrialOrder);
                    resolve();
                });

                let drawDiagonalPromise = new Promise((resolve) => {
                    drawDiagonal(ctx);
                    resolve();
                });

                let drawFeedbackPromise = new Promise((resolve) => {
                    drawFeedback(ctx, blockIndex, presentationIndex, currentTrialsArray);
                    resolve();
                });

                let drawInstructionsReminderPromise = new Promise((resolve) => {
                    drawInstructionsReminder(ctx);
                    resolve();
                });

                // - executing all the promises in parallel and storing variables:
                return Promise.all([
                    drawStimulusLeftPromise,
                    drawStimulusRightPromise,
                    drawDiagonalPromise,
                    //drawFeedbackPromise,
                    //drawInstructionsReminderPromise
                ]).then(() => {
                    // - order of the nodes (changes from trial to trial and is read in "my-plugin-canvas-keyboard-response.js")
                    jsPsych.data.presentedOrder = currentTrialOrder;
                    // - correct answer (its value is read to compute the "correct" variable, does not change from trial to trial but is read to compute "correct" variable from plugin)
                    if (currentExperiment.graphsToDisplay[blockIndex][presentationIndex][0][currentExperiment.graphSize].clique_array === "clique is absent") {
                        // if the first stimulus doesn't have the clique, then the graph with the clique (correct answer) is on the right side
                        jsPsych.data.correctResponse = "arrowright";
                    } else {
                        jsPsych.data.correctResponse = "arrowleft";
                    }
                });

            }

            return drawCanvas

        }


        // Creating feedback audio trials (will be added to timeline after each trial):
        var feedbackAudio = {
            type: jsPsychAudioKeyboardResponse,
            stimulus: function () {
                // defining stimulus based on last response (shuffle, correct answer, wrong answer)
                let lastTrial = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" }).last(1).values()[0]
                if (lastTrial.response == " ")
                    return 'audio_feedback/shuffles/shuffle01.mp3';
                else
                    if (lastTrial.correct)
                        return 'audio_feedback/right/coin01.mp3'
                    else
                        return 'audio_feedback/wrong/error01.mp3'
            },
            choices: "NO_KEYS",
            trial_ends_after_audio: true,
            response_allowed_while_playing: false,
        };


        // creating the blocks of the experiment
        for (let blockIndex = 0; blockIndex < currentExperiment.numberOfBlocks; blockIndex++) {

            // creating the trials for the block
            for (let presentationIndex = 0; presentationIndex < currentExperiment.numberOfPresentationsPerBlock; presentationIndex++) {

                // defining the current trial
                let currentTrial = {
                    type: jsPsychCanvasKeyboardResponse,
                    canvas_size: [currentExperiment.canvasDimensions[0], currentExperiment.canvasDimensions[1]], // LOGICAL COORDINATES [height,width]
                    choices: [' ', 'ArrowLeft', 'ArrowRight'],
                    response_ends_trial: true,
                    // adding the stimuli and the audio feedback to the timeline of the trial
                    timeline: [{ stimulus: generateDrawCanvas(blockIndex, presentationIndex) }, feedbackAudio],     // NB: shuffling of nodes is done inside draw function
                    data: {
                        // storing variables that do not change between trials relative to the same couple of graphs
                        // experiment parameters:
                        block_index: blockIndex,
                        presentation_index: presentationIndex,
                        // graphs parameters:
                        clique_size: currentExperiment.arrayOfCliqueSizes[presentationIndex],
                        graph_size: currentExperiment.graphSize,
                    },

                    on_start: function (currentTrial) {
                        // - when trial starts, graphs have been read:
                        currentTrial.data.graphs_names = [currentExperiment.graphsToDisplay[blockIndex][presentationIndex][0][currentExperiment.graphSize].graph_name, currentExperiment.graphsToDisplay[blockIndex][presentationIndex][1][currentExperiment.graphSize].graph_name]
                        // - accessing the data stored up to now (it will increase progressively):
                        let currentData = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" })
                        // - if no more shuffles are available, only allowing final answers (arrow presses):
                        if (currentData.trials.filter(element => element.block_index == blockIndex && element.presentation_index == presentationIndex).length == currentExperiment.maximumNumberOfShuffles)
                            currentTrial.choices = ['ArrowLeft', 'ArrowRight']
                    },

                    // TODO: LEFT FOR CONTROL, TO BE REMOVED:
                    on_finish: function (data) {

                        let currentData = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" })
                        console.log(currentData)

                    },
                }

                // repeating the trial until a final answer (left/right arrow press) is given:
                let loop_node = {
                    timeline: [currentTrial],
                    loop_function: function () {
                        // isolating the canvas keyboard responses stored up to now (they will increase progressively):
                        let currentData = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" })
                        //currentData.trials.filter(element => element.)
                        if (currentData.last(1).values()[0].response == " ") {
                            // if last response was a spacebar press, repeat the trial
                            console.log("shuffle pressed, repeating trial")
                            return true
                        } else if (currentData.last(1).values()[0].response == 0 || currentData.last(1).values()[0].response == 1) {
                            console.log("final response, going on")
                            // if last response was on left/right arrow, moving to next trial
                            return false
                        }

                    }
                }

                // adding the loop node to the timeline
                timeline.push(loop_node)

            }

            // after each block, present break page
            switch (blockIndex) {
                // if last block just presented, final page will be different
                case (currentExperiment.numberOfBlocks - 1):
                    /* FINAL PAGE */
                    let final_page = {
                        type: jsPsychInstructions,
                        pages: [], // defined inside on_start function (below)
                        key_forward: " ",
                        on_start: function (final_page) {
                            // accessing the array of all the trials completed up to now:
                            let currentTrialsArray = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" }).trials
                            let arrayOfResponsesLastBlock = []  //to compute block score
                            let arrayOfResponses = []   //to compute total score
                            currentTrialsArray.forEach(element => {
                                // creating array of final responses for current block:
                                if (element.block_index == blockIndex && element.hasOwnProperty('correct'))
                                    arrayOfResponsesLastBlock.push(element.correct)
                                // creating array of all final responses:
                                if (element.hasOwnProperty('correct'))
                                    arrayOfResponses.push(element.correct)
                            })
                            // computing score:
                            // - last block score:
                            let numberOfCorrectResponsesLastBlock = arrayOfResponsesLastBlock.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponsesLastBlock = arrayOfResponsesLastBlock.length
                            // - total score:
                            let numberOfCorrectResponses = arrayOfResponses.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponses = arrayOfResponses.length
                            // last trial feedaback: changing background color of SCORE based on correctness of last response
                            let scoreColor = "black"
                            if (arrayOfResponsesLastBlock[arrayOfResponsesLastBlock.length - 1]) {
                                scoreColor = "lawngreen"
                            } else {
                                scoreColor = "red"
                            }
                            final_page.pages = [
                                `<p> 
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:${scoreColor};color:black;display:inline-block;">SCORE: ${numberOfCorrectResponsesLastBlock} / ${numberOfFinalResponsesLastBlock}</div>
                                <br><br><br>                             
                                You completed all the <b> ${currentExperiment.numberOfBlocks}</b> blocks of the experiment. <br><br>
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:gold;color:black;display:inline-block;">TOTAL SCORE: ${numberOfCorrectResponses} / ${numberOfFinalResponses}</div>
                                <br><br>
                                Thank you for your time.
                                <br><br>
                                Press <b>space</b> to exit.
                                </p>`]
                        }
                    };
                    timeline.push(final_page)
                    break;
                default:
                    /* AGREEMENT TO MOVE TO NEXT BLOCK */
                    let move_to_next_block = {
                        type: jsPsychInstructions,
                        pages: [], // defined inside on_start function (below)
                        key_forward: " ",
                        on_start: function (move_to_next_block) {
                            // accessing the array of the trials completed up to now:
                            let currentTrialsArray = jsPsych.data.get().filter({ trial_type: "canvas-keyboard-response" }).trials
                            let arrayOfResponsesPerBlock = []
                            currentTrialsArray.forEach(element => {
                                // creating array of final responses for current block:
                                if (element.block_index == blockIndex && element.hasOwnProperty('correct'))
                                    arrayOfResponsesPerBlock.push(element.correct)
                            })
                            // calculating accuracy for current block:
                            let numberOfCorrectResponsesPerBlock = arrayOfResponsesPerBlock.reduce((a, b) => a + b, 0)
                            let numberOfFinalResponsesPerBlock = arrayOfResponsesPerBlock.length
                            // last trial feedback: changing background color of SCORE based on correctness of last response
                            let scoreColor = "black"
                            if (arrayOfResponsesPerBlock[arrayOfResponsesPerBlock.length - 1]) {
                                scoreColor = "lawngreen"
                            } else {
                                scoreColor = "red"
                            }
                            move_to_next_block.pages = [
                                `<p> 
                                    <div style="font-weight:bold;font-family:system-ui;font-size:2rem;padding-left:1rem;padding-right:1rem;padding-top:1rem;padding-bottom:1rem;background-color:${scoreColor};color:black;display:inline-block;">SCORE: ${numberOfCorrectResponsesPerBlock} / ${numberOfFinalResponsesPerBlock}</div>
                                    <br><br>
                                    So far, you have completed <b> ${(blockIndex + 1)} </b> out of <b>${currentExperiment.numberOfBlocks}</b> blocks. <br>
                                    You still have <b> ${currentExperiment.numberOfBlocks - (blockIndex + 1)} </b> to go.
                                    <br><br>
                                    Remember: <br>
                                    - Press <b> LEFT / RIGHT arrow </b> to choose the triangle with the hidden red tiles. <br>
                                    - Press <b> SPACE </b> to shuffle the triangles. <br><br>
                                    When you feel ready, press <b>space</b> to move to the next block.
                                  </p>`]
                        }
                    };
                    timeline.push(move_to_next_block)
            }

        }

        /* EXITING FULLSCREEN (and re-enabling scrolling) */
        var exit_fullscreen = {
            type: jsPsychFullscreen,
            fullscreen_mode: false,
            delay_after: 0,
            on_start: function () {
                // Select the element with class "jspsych-display-element"
                var displayElement = document.querySelector('.jspsych-display-element');
                // Remove the style attribute with overflow:hidden to allow scrolling
                displayElement.style.overflow = 'auto';
            }            
        }
        timeline.push(exit_fullscreen)

        /* finish connection with pavlovia.org */
        if (document.location.hostname == "run.pavlovia.org"){
            var pavlovia_finish = {
                type: jsPsychPavlovia,
                command: "finish",
                participantId: "JSPSYCH-DEMO",
    
                //NECESSARY WHEN ADDING PROLIFIC:
                //completedCallback: function (){
                //    window.location.replace('https://app.prolific.co/submissions/complete?cc=C180BZKR');
                //},
    
            };
        timeline.push(pavlovia_finish);
        }             


        /* start the experiment */
        jsPsych.run(timeline);

    </script>

</body>

</html>